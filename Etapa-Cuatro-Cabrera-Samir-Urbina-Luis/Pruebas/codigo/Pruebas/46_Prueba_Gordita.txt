$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave

$* 
  Prueba_PR_Estructura.ne
  Propósito: Verificar el reconocimiento de palabras reservadas de estructura del programa
  Probar: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint
  Fecha: 28/04/2025
*$

$$ Prueba de la estructura básica del programa NotchEngine
$$ Verificando las palabras reservadas: WorldName, Bedrock, ResourcePack, Inventory, Recipe, CraftingTable, SpawnPoint

WorldName PruebaEstructura:

Bedrock 
    Obsidian Stack MAX_VALOR 100;
    Obsidian Spider SALUDO "Prueba de estructura";


ResourcePack 
    Anvil Stack -> Spider;


Inventory 
    Stack contador = 0;
    Spider mensaje = "Hola mundo";


Recipe 
    Spell sumar(Stack :: a, b) -> Stack;
    Ritual mostrarMensaje(Spider :: texto);


CraftingTable 
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado

    Ritual mostrarMensaje(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
    PolloAsado


SpawnPoint 
    PolloCrudo
        dropperSpider(SALUDO);
        Stack resultado = sumar(5, 10);
        dropperSpider("El resultado es: " bind resultado);
    PolloAsado

worldSave
$* 
  Prueba_PR_Tipos.ne
  Propósito: Verificar reconocimiento de tipos de datos en NotchEngine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de los tipos de datos en NotchEngine
$$ Verificando: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity

WorldName PruebaTipos:

Inventory

    $$ Declaraciones de variables de cada tipo

    $$ Stack - Tipo de dato entero
    Stack entero = 42;
    
    $$ Rune - Tipo de dato carácter
    Rune caracter = 'N';
    
    $$ Spider - Tipo de dato string
    Spider texto = "NotchEngine";
    
    $$ Torch - Tipo de dato booleano
    Torch verdadero = On;
    Torch falso = Off;
    
    $$ Chest - Tipo de dato conjunto
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    
    $$ Book - Tipo de dato archivo de texto
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Ghast - Tipo de datos números flotantes
    Ghast decimal = 3.14159;
    
    $$ Shelf - Tipo de dato arreglos
    Shelf[5] Stack arreglo = [1, 2, 3, 4, 5];
    
    $$ Entity - Tipo de dato registros
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador = {nombre: "Steve", nivel: 1, salud: 20.0};

SpawnPoint

    PolloCrudo
        dropperSpider("Prueba de tipos completada");
    PolloAsado

worldSave

$* 
  Prueba_PR_Booleanos.ne
  Propósito: Verificar reconocimiento de literales booleanas (On, Off)
  Probar: Torch, And, Or, Not
  Fecha: 28/04/2025
*$

$$ Prueba de literales booleanas en NotchEngine
$$ Verificando: On, Off

WorldName PruebaBooleanos:

Bedrock

    Obsidian Torch VERDADERO On;
    Obsidian Torch FALSO Off;

Inventory

    $$ Declaración e inicialización con valores booleanos
    Torch activo = On;
    Torch inactivo = Off;
    
    $$ Variables para almacenar resultados de operaciones lógicas
    Torch resultado1;
    Torch resultado2;
    Torch resultado3;
    Torch resultado4;
    Torch resultado5;

SpawnPoint

    PolloCrudo
        $$ Mostrar valores booleanos directos
        dropperSpider("Valor de On: ");
        dropperTorch(On);
        
        dropperSpider("Valor de Off: ");
        dropperTorch(Off);
        
        $$ Operaciones lógicas con literales booleanas
        resultado1 = On and On;
        dropperSpider("On and On: ");
        dropperTorch(resultado1);
        
        resultado2 = On and Off;
        dropperSpider("On and Off: ");
        dropperTorch(resultado2);
        
        resultado3 = On or Off;
        dropperSpider("On or Off: ");
        dropperTorch(resultado3);
        
        resultado4 = Off or Off;
        dropperSpider("Off or Off: ");
        dropperTorch(resultado4);
        
        resultado5 = not On;
        dropperSpider("not On: ");
        dropperTorch(resultado5);
        
        $$ Uso en estructuras de control
        target On craft hit
        PolloCrudo
            dropperSpider("Condición On es verdadera");
        PolloAsado
        
        target Off craft hit
        PolloCrudo
            dropperSpider("Esto no debería mostrarse");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición Off es falsa");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Bloques.ne
  Propósito: Verificar reconocimiento de delimitadores de bloques (PolloCrudo, PolloAsado)
  Probar: PolloCrudo, PolloAsado
  Fecha: 28/04/2025
*$

$$ Prueba de delimitadores de bloques en NotchEngine
$$ Verificando: PolloCrudo, PolloAsado

WorldName PruebaBloques:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack acumulador = 0;
    Stack resultado = 0;
    Spider mensaje = "Prueba de bloques PolloCrudo y PolloAsado";

CraftingTable

    $$ Función con bloques de código
    Spell sumarPares(Stack :: limite) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Bloque anidado dentro de una estructura de control
        walk i set 1 to limite craft
        PolloCrudo
            target i % 2 is 0 craft hit
            PolloCrudo
                suma += i;
            PolloAsado
        PolloAsado
        
        respawn suma;
    PolloAsado
    
    $$ Función con diferentes niveles de anidamiento de bloques
    Spell calcularFactorial(Stack :: n) -> Stack
    PolloCrudo
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Bloque dentro de una expresión
        Stack resultado = n * calcularFactorial(n - 1);
        respawn resultado;
    PolloAsado

SpawnPoint

    $$ Bloque principal
    PolloCrudo
        $$ Bloque simple
        PolloCrudo
            contador = 5;
            dropperSpider(mensaje);
        PolloAsado
        
        $$ Bloque dentro de una estructura repeater
        repeater contador > 0 craft
        PolloCrudo
            acumulador += contador;
            magma contador;
            
            $$ Bloque anidado dentro de un condicional dentro de un bucle
            target contador is 2 craft hit
            PolloCrudo
                dropperSpider("Contador es igual a 2");
                $$ Otro bloque más anidado
                PolloCrudo
                    dropperSpider("Este es un bloque muy anidado");
                PolloAsado
            PolloAsado
        PolloAsado
        
        $$ Uso de bloques en estructura condicional
        target acumulador > 10 craft hit
        PolloCrudo
            dropperSpider("Acumulador es mayor que 10");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Acumulador es menor o igual a 10");
        PolloAsado
        
        $$ Bloque en estructura spawner-exhausted
        spawner
        PolloCrudo
            soulsand resultado;
            target resultado > 5 craft hit creeper;
        PolloAsado
        exhausted resultado > 10;
        
        dropperSpider("Valor final del resultado: " bind resultado);
    PolloAsado

worldSave

$* 
  Prueba_PR_Control.ne
  Propósito: Verificar reconocimiento de palabras de control de flujo
  Probar: Entity, PolloCrudo, PolloAsado, Punto, SpawnPoint, Inventory, WorldName
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas de control de flujo en NotchEngine
$$ Verificando: repeater, craft, target, hit, miss, jukebox, disc, silence, 
$$ spawner, exhausted, walk, set, to, step, wither

WorldName PruebaControl:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack opcion = 2;
    Torch condicion = On;
    Stack iterador = 0;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto coordenada;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de repeater (while) con craft
        dropperSpider("Prueba de repeater:");
        contador = 5;
        repeater contador > 0 craft
        PolloCrudo
            dropperStack(contador);
            magma contador;
        PolloAsado
        
        $$ 2. Prueba de target (if) con hit y miss
        dropperSpider("Prueba de target con hit y miss:");
        target condicion craft hit
        PolloCrudo
            dropperSpider("Condición es verdadera");
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Condición es falsa");
        PolloAsado
        
        $$ 3. Prueba de jukebox (switch) con disc y silence
        dropperSpider("Prueba de jukebox con disc y silence:");
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
        PolloAsado
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
        PolloAsado
        silence:
        PolloCrudo
            dropperSpider("Ninguna opción válida seleccionada");
        PolloAsado
        
        $$ 4. Prueba de spawner (do-while) con exhausted
        dropperSpider("Prueba de spawner con exhausted:");
        contador = 0;
        spawner
        PolloCrudo
            soulsand contador;
            dropperStack(contador);
        PolloAsado
        exhausted contador >= 3;
        
        $$ 5. Prueba de walk (for) con set, to, step
        dropperSpider("Prueba de walk con set, to, step:");
        walk i set 0 to 10 step 2 craft
        PolloCrudo
            dropperStack(i);
        PolloAsado
        
        $$ 6. Prueba de wither (with)
        dropperSpider("Prueba de wither:");
        coordenada@x = 10;
        coordenada@y = 20;
        wither coordenada craft
        PolloCrudo
            dropperSpider("Coordenadas: (" bind x bind ", " bind y bind ")");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Saltos.ne
  Propósito: Verificar palabras para saltos y terminación (creeper, enderPearl, ragequit)
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para saltos y terminación en NotchEngine
$$ Verificando: creeper, enderPearl, ragequit

WorldName PruebaSaltos:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack totalPares = 0;
    Stack totalImpares = 0;
    Torch errorCritico = Off;

SpawnPoint

    PolloCrudo
        $$ 1. Prueba de creeper (break) para salir de un bucle
        dropperSpider("Prueba de creeper (break):");
        walk i set 1 to 10 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
            
            $$ Salimos del bucle cuando i llega a 5
            target i is 5 craft hit
            PolloCrudo
                dropperSpider("Encontrado 5, saliendo del bucle con creeper");
                creeper;
            PolloAsado
        PolloAsado
        
        $$ 2. Prueba de enderPearl (continue) para saltar a la siguiente iteración
        dropperSpider("Prueba de enderPearl (continue):");
        walk i set 1 to 10 craft
        PolloCrudo
            $$ Saltamos los números pares
            target i % 2 is 0 craft hit
            PolloCrudo
                dropperSpider("Número par " bind i bind ", saltando con enderPearl");
                enderPearl;
            PolloAsado
            
            $$ Esta parte solo se ejecuta para números impares
            dropperSpider("Procesando número impar: " bind i);
            totalImpares += i;
        PolloAsado
        
        dropperSpider("Total de números impares: " bind totalImpares);
        
        $$ 3. Prueba de creeper y enderPearl en bucles anidados
        dropperSpider("Prueba de control de flujo en bucles anidados:");
        walk i set 1 to 5 craft
        PolloCrudo
            walk j set 1 to 5 craft
            PolloCrudo
                $$ Saltar la iteración cuando j es 3
                target j is 3 craft hit
                PolloCrudo
                    dropperSpider("Saltando j=3 con enderPearl");
                    enderPearl;
                PolloAsado
                
                $$ Salir del bucle interno cuando j es 4
                target j is 4 craft hit
                PolloCrudo
                    dropperSpider("Saliendo del bucle interno con creeper en j=4");
                    creeper;
                PolloAsado
                
                dropperSpider("i=" bind i bind ", j=" bind j);
            PolloAsado
        PolloAsado
        
        $$ 4. Prueba de ragequit (halt) para terminar el programa
        $$ Nota: Esta parte debe estar comentada en pruebas reales
        $$ o al final del programa, ya que detiene la ejecución
        
        dropperSpider("Prueba de ragequit (halt):");
        target errorCritico craft hit
        PolloCrudo
            dropperSpider("Error crítico detectado, terminando programa con ragequit");
            $$ ragequit;  $$ Comentado para evitar terminar la prueba
        PolloAsado
        
        dropperSpider("Esta línea se mostrará si errorCritico es Off");
        
        $$ Ejemplo descomentado pero que nunca se ejecutará
        target Off craft hit
        PolloCrudo
            dropperSpider("Esta condición nunca se cumple");
            ragequit;
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_PR_Funciones.ne
  Propósito: Verificar palabras para funciones y procedimientos (Spell, Ritual, respawn, ender_pearl)
  Probar: Spell, Ritual, respawn, ender_pearl, crafting_table
  Fecha: 28/04/2025
*$

$$ Prueba de palabras reservadas para funciones y procedimientos en NotchEngine
$$ Verificando: Spell, Ritual, respawn

WorldName PruebaFunciones:

$$ Sección de prototipos
Recipe

    $$ Prototipos de funciones (Spell)
    Spell sumar(Stack :: a, b) -> Stack;
    Spell factorial(Stack :: n) -> Stack;
    Spell esPar(Stack :: numero) -> Torch;
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack;
    
    $$ Prototipos de procedimientos (Ritual)
    Ritual imprimirLinea(Spider :: texto);
    Ritual mostrarResultado(Spider :: operacion; Stack valor);
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano);

$$ Sección de rutinas (implementación de funciones y procedimientos)
CraftingTable

    $$ Funciones (Spell) con instrucción de retorno (respawn)
    Spell sumar(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Retorno con expresión simple
        respawn a + b;
    PolloAsado
    
    Spell factorial(Stack :: n) -> Stack
    PolloCrudo
        $$ Retorno temprano con condición
        target n <= 1 craft hit
        PolloCrudo
            respawn 1;
        PolloAsado
        
        $$ Retorno con expresión compleja y llamada recursiva
        respawn n * factorial(n - 1);
    PolloAsado
    
    Spell esPar(Stack :: numero) -> Torch
    PolloCrudo
        target numero % 2 is 0 craft hit
        PolloCrudo
            respawn On;
        PolloAsado
        miss
        PolloCrudo
            respawn Off;
        PolloAsado
    PolloAsado
    
    Spell sumarArreglo(Shelf[10] Stack :: numeros; Stack tamano) -> Stack
    PolloCrudo
        Stack suma = 0;
        
        $$ Verificar parámetros
        target tamano <= 0 craft hit
        PolloCrudo
            respawn 0;  $$ Retorno temprano
        PolloAsado
        
        $$ Sumar elementos del arreglo
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            suma += numeros[i];
        PolloAsado
        
        respawn suma;  $$ Retorno al final
    PolloAsado
    
    $$ Procedimientos (Ritual) con posibles retornos vacíos
    Ritual imprimirLinea(Spider :: texto)
    PolloCrudo
        dropperSpider(texto);
        dropperSpider("------------------------");
    PolloAsado
    
    Ritual mostrarResultado(Spider :: operacion; Stack valor)
    PolloCrudo
        dropperSpider(operacion bind ": " bind valor);
        
        $$ Retorno temprano sin valor
        target valor < 0 craft hit
        PolloCrudo
            dropperSpider("¡Valor negativo!");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Valor válido procesado");
    PolloAsado
    
    Ritual imprimirArreglo(Shelf[10] Stack :: arr; Stack tamano)
    PolloCrudo
        target tamano <= 0 craft hit
        PolloCrudo
            dropperSpider("Arreglo vacío");
            respawn;  $$ Retorno vacío temprano
        PolloAsado
        
        dropperSpider("Elementos del arreglo:");
        walk i set 0 to tamano - 1 craft
        PolloCrudo
            dropperStack(arr[i]);
        PolloAsado
    PolloAsado

$$ Punto de entrada con llamadas a funciones y procedimientos
SpawnPoint

    PolloCrudo
        $$ Declaración de variables
        Stack a = 5;
        Stack b = 7;
        Stack resultado;
        Shelf[10] Stack numeros;
        
        $$ Inicializar arreglo
        walk i set 0 to 9 craft
        PolloCrudo
            numeros[i] = i + 1;
        PolloAsado
        
        $$ Llamadas a funciones (invocación directa)
        resultado = sumar(a, b);
        dropperSpider("Suma: " bind resultado);
        
        resultado = factorial(5);
        dropperSpider("Factorial de 5: " bind resultado);
        
        Torch esPar5 = esPar(5);
        dropperSpider("¿Es 5 par?: ");
        dropperTorch(esPar5);
        
        resultado = sumarArreglo(numeros, 10);
        dropperSpider("Suma del arreglo: " bind resultado);
        
        $$ Llamadas a procedimientos
        imprimirLinea("==== Resultados de pruebas ====");
        
        mostrarResultado("Suma de 5 y 7", sumar(a, b));
        mostrarResultado("Valor negativo", -10);
        
        imprimirArreglo(numeros, 5);
        imprimirArreglo(numeros, 0);
    PolloAsado

worldSave

$* 
  Prueba_PR_Operadores.ne
  Propósito: Verificar operadores textuales reales en Notch Engine
  Probar: soulsand, magma, and, or, not, xor, bind, #, from ##, except ##, seek,
          add, drop, feed, map, biom, void, isEngraved, isInscribed, etchUp, etchDown,
          unlock, lock, make, gather, forge, expand
  Fecha: 28/04/2025
*$

WorldName PruebaOperadores:

Inventory {
    Stack contador = 5; $$ Inicializa contador con 5
    Torch condicion1 = On; $$ Condición 1 es verdadera
    Torch condicion2 = Off; $$ Condición 2 es falsa
    Torch resultado; $$ Variable para almacenar resultados booleanos

    Spider texto1 = "Notch"; $$ Texto inicial "Notch"
    Spider texto2 = "Engine"; $$ Texto inicial "Engine"
    Spider textoCompleto; $$ Variable para texto combinado

    Rune letra = 'a'; $$ Letra inicial 'a'
    Rune letraMayuscula; $$ Variable para letra mayúscula

    Chest conjunto1 = {: 1, 2, 3 :}; $$ Conjunto inicial con 1, 2, 3
    Chest conjunto2 = {: 3, 4, 5 :}; $$ Conjunto inicial con 3, 4, 5
    Chest conjuntoResultado; $$ Variable para resultado de conjuntos

    Book archivo1 = {/ "datos.txt", 'E' /}; $$ Archivo para escritura "datos.txt"
    Book archivo2 = {/ "resultado.txt", 'E' /}; $$ Archivo para escritura "resultado.txt"

    Ghast flotante1 = 3.5; $$ Flotante inicial 3.5
    Ghast flotante2 = 2.5; $$ Flotante inicial 2.5
    Ghast resultadoFlotante; $$ Variable para resultado de operaciones flotantes
}

SpawnPoint {
PolloCrudo
    $$ soulsand y magma
    soulsand contador; $$ Aplica soulsand a contador
    magma contador; $$ Aplica magma a contador

    $$ and, or, not, xor
    resultado = condicion1 and condicion2; $$ Resultado es verdadero si ambas condiciones son verdaderas
    resultado = condicion1 or condicion2; $$ Resultado es verdadero si al menos una condición es verdadera
    resultado = not condicion1; $$ Resultado es el opuesto de condicion1
    resultado = condicion1 xor condicion2; $$ Resultado es verdadero si solo una condición es verdadera

    $$ bind, #, from ##, except ##, seek
    textoCompleto = bind(texto1, " " bind texto2); $$ Combina texto1 y texto2 con un espacio
    Stack longitud = #(textoCompleto); $$ Longitud de textoCompleto
    Spider subcadena = from textoCompleto ## 0 ## 5; $$ Subcadena de textoCompleto desde 0 hasta 5
    Spider sinNotch = except textoCompleto ## 0 ## 6; $$ Elimina caracteres de 0 a 6 en textoCompleto
    Stack posicion = seek(textoCompleto, "Engine"); $$ Posición de "Engine" en textoCompleto

    $$ isEngraved, isInscribed, etchUp, etchDown
    Torch esLetra = isEngraved(letra); $$ Verifica si letra es una letra
    Torch esDigito = isInscribed(letra); $$ Verifica si letra es un dígito
    letraMayuscula = etchUp(letra); $$ Convierte letra a mayúscula
    Rune letraMinuscula = etchDown(letraMayuscula); $$ Convierte letraMayuscula a minúscula

    $$ Operaciones de conjuntos
    add(conjunto1, 4); $$ Añade 4 a conjunto1
    drop(conjunto1, 2); $$ Elimina 2 de conjunto1
    conjuntoResultado = feed(conjunto1, conjunto2); $$ Intersección de conjunto1 y conjunto2
    resultado = map(conjunto1, 3); $$ Verifica si 3 está en conjunto1
    Torch conjuntoVacio = void(conjunto1); $$ Verifica si conjunto1 está vacío

    $$ Operaciones de archivos
    unlock(archivo1); $$ Abre archivo1 para escritura
    forge(archivo1, "Texto de prueba"); $$ Escribe "Texto de prueba" en archivo1
    lock(archivo1); $$ Cierra archivo1

    Book nuevoArchivo = make({/ "nuevo.txt", 'E' /}); $$ Crea nuevo archivo "nuevo.txt"
    forge(nuevoArchivo, "Contenido del nuevo archivo"); $$ Escribe en nuevoArchivo
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    unlock(archivo1); $$ Abre archivo1
    unlock(nuevoArchivo); $$ Abre nuevoArchivo
    expand(archivo1, nuevoArchivo); $$ Expande archivo1 con contenido de nuevoArchivo
    lock(archivo1); $$ Cierra archivo1
    lock(nuevoArchivo); $$ Cierra nuevoArchivo

    $$ Operadores de flotantes
    resultadoFlotante = flotante1 :+ flotante2; $$ Suma de flotante1 y flotante2
    resultadoFlotante = flotante1 :- flotante2; $$ Resta de flotante1 y flotante2
    resultadoFlotante = flotante1 :* flotante2; $$ Multiplicación de flotante1 y flotante2
    resultadoFlotante = flotante1 :// flotante2; $$ División de flotante1 y flotante2
    resultadoFlotante = flotante1 :% flotante2; $$ Módulo de flotante1 y flotante2
PolloAsado
}

worldSave
$* 
  Prueba_Lit_Enteros.ne
  Propósito: Verificar reconocimiento de literales enteros (positivos, negativos, cero)
  Probar: Stack
  Fecha: 28/04/2025
*$

$$ Prueba de literales enteros en NotchEngine
$$ Verificando: enteros positivos, negativos y cero

WorldName PruebaLitEnteros:

Bedrock

    $$ Constantes enteras
    Obsidian Stack CERO 0;
    Obsidian Stack POSITIVO 42;
    Obsidian Stack NEGATIVO -42;
    Obsidian Stack MAX_VALOR 2147483647;  $$ Valor máximo de 32 bits
    Obsidian Stack MIN_VALOR -2147483648; $$ Valor mínimo de 32 bits

Inventory

    $$ Variables con literales enteros
    Stack cero = 0;
    Stack uno = 1;
    Stack diez = 10;
    Stack cien = 100;
    Stack mil = 1000;
    Stack millon = 1000000;
    
    $$ Enteros negativos
    Stack negUno = -1;
    Stack negDiez = -10;
    Stack negCien = -100;
    Stack negMil = -1000;
    Stack negMillon = -1000000;
    
    $$ Valor entero máximo y mínimo (aproximadamente)
    Stack maxInt = 2147483647;
    Stack minInt = -2147483648;
    
    $$ Variables para resultados
    Stack resultado = 0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales enteros directos
        resultado = 5 + 3;      $$ 8
        dropperSpider("5 + 3 = " bind resultado);
        
        resultado = 10 - 7;     $$ 3
        dropperSpider("10 - 7 = " bind resultado);
        
        resultado = 6 * 4;      $$ 24
        dropperSpider("6 * 4 = " bind resultado);
        
        resultado = 20 // 4;    $$ 5
        dropperSpider("20 // 4 = " bind resultado);
        
        resultado = 17 % 5;     $$ 2
        dropperSpider("17 % 5 = " bind resultado);
        
        $$ Uso de literales enteros en expresiones complejas
        resultado = (5 + 3) * 2 - 4 // 2;    $$ 16 - 2 = 14
        dropperSpider("(5 + 3) * 2 - 4 // 2 = " bind resultado);
        
        $$ Operaciones con literales enteros negativos
        resultado = -5 + 10;    $$ 5
        dropperSpider("-5 + 10 = " bind resultado);
        
        resultado = 5 + -10;    $$ -5
        dropperSpider("5 + -10 = " bind resultado);
        
        resultado = -5 * -4;    $$ 20
        dropperSpider("-5 * -4 = " bind resultado);
        
        $$ Uso de literales enteros en estructuras de control
        walk i set 1 to 5 craft
        PolloCrudo
            dropperSpider("Iteración: " bind i);
        PolloAsado
        
        $$ Comparaciones con literales enteros
        target 10 > 5 craft hit
        PolloCrudo
            dropperSpider("10 es mayor que 5");
        PolloAsado
        
        target 0 is 0 craft hit
        PolloCrudo
            dropperSpider("0 es igual a 0");
        PolloAsado
        
        target -10 < -5 craft hit
        PolloCrudo
            dropperSpider("-10 es menor que -5");
        PolloAsado
        
        $$ Operaciones con valores extremos (cuidado con overflow)
        dropperSpider("Valor máximo de entero: " bind maxInt);
        dropperSpider("Valor mínimo de entero: " bind minInt);
        
        $$ Verificación del cero
        target 0 is cero craft hit
        PolloCrudo
            dropperSpider("Ambas representaciones de cero son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Flotantes.ne
  Propósito: Verificar reconocimiento de números flotantes (con parte decimal, sin parte decimal, negativos)
  Probar: Ghast
  Fecha: 28/04/2025
*$

$$ Prueba de literales flotantes en NotchEngine
$$ Verificando: flotantes con parte decimal, sin parte decimal, y negativos

WorldName PruebaLitFlotantes:

Bedrock

    $$ Constantes flotantes
    Obsidian Ghast CERO_PUNTO_CERO 0.0;
    Obsidian Ghast PI 3.14159;
    Obsidian Ghast E 2.71828;
    Obsidian Ghast NEG_PI -3.14159;
    Obsidian Ghast GRAVEDAD -9.8;

Inventory

    $$ Flotantes positivos con parte decimal
    Ghast decimal1 = 0.5;
    Ghast decimal2 = 1.25;
    Ghast decimal3 = 3.14159;
    Ghast decimal4 = 2.71828;
    Ghast decimal5 = 123.456;
    
    $$ Flotantes negativos con parte decimal
    Ghast negDecimal1 = -0.5;
    Ghast negDecimal2 = -1.25;
    Ghast negDecimal3 = -3.14159;
    Ghast negDecimal4 = -2.71828;
    Ghast negDecimal5 = -123.456;
    
    $$ Formas alternativas (punto al principio, sin parte decimal)
    Ghast decimal6 = .5;       $$ Sin cero al principio, comienza con punto
    Ghast decimal7 = 5.;       $$ Sin decimales, termina con punto
    
    $$ Números con muchos decimales
    Ghast precisionAlta = 1.123456789012345;
    
    $$ Números muy pequeños y muy grandes
    Ghast muyPequeno = 0.0000001;
    Ghast muyGrande = 1000000.0;
    
    $$ Variables para resultados
    Ghast resultado = 0.0;

SpawnPoint

    PolloCrudo
        $$ Operaciones aritméticas con literales flotantes directos
        resultado = 5.5 :+ 3.5;      $$ 9.0
        dropperSpider("5.5 :+ 3.5 = ");
        dropperGhast(resultado);
        
        resultado = 10.75 :- 7.25;   $$ 3.5
        dropperSpider("10.75 :- 7.25 = ");
        dropperGhast(resultado);
        
        resultado = 6.5 :* 2.0;      $$ 13.0
        dropperSpider("6.5 :* 2.0 = ");
        dropperGhast(resultado);
        
        resultado = 20.0 :// 4.0;    $$ 5.0
        dropperSpider("20.0 :// 4.0 = ");
        dropperGhast(resultado);
        
        resultado = 7.5 :% 2.0;      $$ 1.5
        dropperSpider("7.5 :% 2.0 = ");
        dropperGhast(resultado);
        
        $$ Uso de notaciones decimales alternativas
        resultado = .5 :+ 2.;        $$ 0.5 + 2.0 = 2.5
        dropperSpider(".5 :+ 2. = ");
        dropperGhast(resultado);
        
        $$ Operaciones con literales flotantes negativos
        resultado = -5.5 :+ 10.0;    $$ 4.5
        dropperSpider("-5.5 :+ 10.0 = ");
        dropperGhast(resultado);
        
        resultado = 5.0 :+ -10.0;    $$ -5.0
        dropperSpider("5.0 :+ -10.0 = ");
        dropperGhast(resultado);
        
        resultado = -5.0 :* -4.0;    $$ 20.0
        dropperSpider("-5.0 :* -4.0 = ");
        dropperGhast(resultado);
        
        $$ Expresiones complejas con flotantes
        resultado = (2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0;    $$ 12.0 - 2.5 = 9.5
        dropperSpider("(2.5 :+ 1.5) :* 3.0 :- 5.0 :// 2.0 = ");
        dropperGhast(resultado);
        
        $$ Comparaciones con flotantes
        target 3.14 > 3.0 craft hit
        PolloCrudo
            dropperSpider("3.14 es mayor que 3.0");
        PolloAsado
        
        target 0.1 :+ 0.2 isNot 0.3 craft hit  $$ Debido a errores de precisión en flotantes
        PolloCrudo
            dropperSpider("0.1 + 0.2 no es exactamente igual a 0.3 (error de precisión)");
            dropperGhast(0.1 :+ 0.2);
        PolloAsado
        
        $$ Conversión y coherción de tipos
        Stack entero = 3.14159 >> Stack;  $$ Cohersión a entero (trunca a 3)
        dropperSpider("PI truncado a entero: " bind entero);
        
        $$ Mostrar valores con diferentes precisiones
        dropperSpider("Valor de PI: ");
        dropperGhast(PI);
        
        dropperSpider("Número con alta precisión: ");
        dropperGhast(precisionAlta);
        
        dropperSpider("Número muy pequeño: ");
        dropperGhast(muyPequeno);
        
        dropperSpider("Número muy grande: ");
        dropperGhast(muyGrande);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Caracteres.ne
  Propósito: Verificar reconocimiento de caracteres (letras, dígitos, símbolos, escapes)
  Probar: Rune, dropperRune, dropperSpider, dropperTorch
  Fecha: 28/04/2025
*$

$$ Prueba de literales de caracteres en NotchEngine
$$ Verificando: letras, dígitos, símbolos y secuencias de escape

WorldName PruebaLitCaracteres:

Bedrock

    $$ Constantes de caracteres
    Obsidian Rune LETRA_A 'A';
    Obsidian Rune LETRA_Z 'Z';
    Obsidian Rune DIGITO_0 '0';
    Obsidian Rune DIGITO_9 '9';
    Obsidian Rune NUEVA_LINEA '\n';
    Obsidian Rune TABULACION '\t';

Inventory

    $$ Letras mayúsculas
    Rune letraA = 'A';
    Rune letraB = 'B';
    Rune letraC = 'C';
    Rune letraZ = 'Z';
    
    $$ Letras minúsculas
    Rune letraMina = 'a';
    Rune letraMinb = 'b';
    Rune letraMinc = 'c';
    Rune letraMinz = 'z';
    
    $$ Dígitos
    Rune digito0 = '0';
    Rune digito1 = '1';
    Rune digito5 = '5';
    Rune digito9 = '9';
    
    $$ Símbolos comunes
    Rune simboloExclamacion = '!';
    Rune simboloInterrogacion = '?';
    Rune simboloArroba = '@';
    Rune simboloNumeral = '#';
    Rune simboloDolar = '$';
    Rune simboloPorcentaje = '%';
    Rune simboloAmpersand = '&';
    Rune simboloAsterisco = '*';
    Rune simboloParentesisIzq = '(';
    Rune simboloParentesisDer = ')';
    Rune simboloGuion = '-';
    Rune simboloGuionBajo = '_';
    Rune simboloIgual = '=';
    Rune simboloMas = '+';
    Rune simboloCorcheteIzq = '[';
    Rune simboloCorcheteDer = ']';
    Rune simboloLlaveIzq = '{';
    Rune simboloLlaveDer = '}';
    Rune simboloPuntoyComa = ';';
    Rune simboloDosPuntos = ':';
    Rune simboloComillaSimple = '\'';
    Rune simboloComillaDoble = '"';
    Rune simboloBarra = '/';
    Rune simboloBarraInversa = '\\';
    Rune simboloBarraVertical = '|';
    Rune simboloComa = ',';
    Rune simboloPunto = '.';
    Rune simboloMenorQue = '<';
    Rune simboloMayorQue = '>';
    
    $$ Secuencias de escape
    Rune escapeNuevaLinea = '\n';
    Rune escapeTabulacion = '\t';
    Rune escapeRetornoCarro = '\r';
    Rune escapeBarraInversa = '\\';
    Rune escapeComillaSimple = '\'';
    Rune escapeComillaDoble = '\"';

SpawnPoint

    PolloCrudo
        $$ Mostrar algunos caracteres
        dropperSpider("Letras mayúsculas: ");
        dropperRune(letraA);
        dropperRune(letraB);
        dropperRune(letraC);
        
        dropperSpider("Letras minúsculas: ");
        dropperRune(letraMina);
        dropperRune(letraMinb);
        dropperRune(letraMinc);
        
        dropperSpider("Dígitos: ");
        dropperRune(digito0);
        dropperRune(digito1);
        dropperRune(digito5);
        dropperRune(digito9);
        
        dropperSpider("Símbolos: ");
        dropperRune(simboloExclamacion);
        dropperRune(simboloInterrogacion);
        dropperRune(simboloArroba);
        dropperRune(simboloNumeral);
        
        $$ Pruebas de acceso a caracteres en strings
        Spider texto = "NotchEngine";
        Rune primerCaracter = texto[0];       $$ 'N'
        Rune ultimoCaracter = texto[10];      $$ 'e'
        
        dropperSpider("Primer carácter de 'NotchEngine': ");
        dropperRune(primerCaracter);
        
        dropperSpider("Último carácter de 'NotchEngine': ");
        dropperRune(ultimoCaracter);
        
        $$ Pruebas de operaciones con caracteres
        Rune letraMinuscula = 'a';
        Rune letraMayuscula = etchUp(letraMinuscula);    $$ 'A'
        
        dropperSpider("Minúscula: ");
        dropperRune(letraMinuscula);
        
        dropperSpider("Convertida a mayúscula: ");
        dropperRune(letraMayuscula);
        
        letraMinuscula = etchDown(letraMayuscula);      $$ 'a'
        
        dropperSpider("Convertida nuevamente a minúscula: ");
        dropperRune(letraMinuscula);
        
        $$ Verificaciones de tipo de carácter
        Torch esLetra = isEngraved('A');       $$ On
        Torch esDigito = isInscribed('5');     $$ On
        
        dropperSpider("¿'A' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'5' es un dígito? ");
        dropperTorch(esDigito);
        
        esLetra = isEngraved('7');            $$ Off
        esDigito = isInscribed('K');          $$ Off
        
        dropperSpider("¿'7' es una letra? ");
        dropperTorch(esLetra);
        
        dropperSpider("¿'K' es un dígito? ");
        dropperTorch(esDigito);
        
        $$ Convertir carácter a valor ASCII (entero)
        Stack valorAsciiA = letraA >> Stack;    $$ 65
        
        dropperSpider("Valor ASCII de 'A': " bind valorAsciiA);
    PolloAsado

worldSave

$* 
  Prueba_Lit_Strings.ne
  Propósito: Verificar reconocimiento de cadenas (vacías, con espacios, con escape sequences)
  Probar: Spider, Rune, dropperSpider, dropperRune
  Fecha: 28/04/2025
*$

$$ Prueba de literales de cadenas en NotchEngine
$$ Verificando: cadenas vacías, con espacios, con secuencias de escape

WorldName PruebaLitStrings:

Bedrock

    $$ Constantes de cadenas
    Obsidian Spider VACIO "";
    Obsidian Spider ESPACIO " ";
    Obsidian Spider SALUDO "Hola Mundo";
    Obsidian Spider CON_COMILLAS "Este string tiene \"comillas\"";
    Obsidian Spider MULTILINEA "Primera línea\nSegunda línea";

Inventory

    $$ Cadenas vacías y simples
    Spider cadenaVacia = "";
    Spider espacioSimple = " ";
    Spider cadenaSimple = "Texto simple";
    
    $$ Cadenas con diferentes tipos de caracteres
    Spider conNumeros = "Notch Engine v1.0";
    Spider conSimbolos = "¡Hola, mundo! ¿Cómo estás?";
    Spider conCaracteresEspeciales = "#$%&/()=?¡";
    
    $$ Cadenas con secuencias de escape
    Spider conNuevaLinea = "Primera línea\nSegunda línea";
    Spider conTabulacion = "Columna1\tColumna2\tColumna3";
    Spider conRetornoCarro = "Texto con\rretorno de carro";
    Spider conBarraInversa = "Ruta de archivo: C:\\Archivos\\datos.txt";
    Spider conComillasSimples = "Texto con 'comillas simples'";
    Spider conComillasDobles = "Texto con \"comillas dobles\"";
    
    $$ Cadenas con caracteres mixtos
    Spider mixto = "Abc123!@#\n\t\"'";
    
    $$ Cadenas largas
    Spider cadenaLarga = "Esta es una cadena de texto más larga que contiene múltiples palabras, números como 12345, y símbolos como $%&. Es útil para probar el manejo de cadenas extensas en el analizador léxico y asegurarse de que no hay limitaciones inesperadas en la longitud de las cadenas.";
    
    $$ Cadenas para operaciones
    Spider prefijo = "Notch";
    Spider sufijo = "Engine";
    Spider resultado;

SpawnPoint

    PolloCrudo
        $$ Mostrar algunas cadenas
        dropperSpider("Cadena simple: " bind cadenaSimple);
        dropperSpider("Cadena con números: " bind conNumeros);
        dropperSpider("Cadena con símbolos: " bind conSimbolos);
        
        $$ Operaciones con strings
        resultado = bind(prefijo, " " bind sufijo);  $$ "Notch Engine"
        dropperSpider("Concatenación: " bind resultado);
        
        Stack longitud = #(resultado);              $$ 12
        dropperSpider("Longitud de '" bind resultado bind "': " bind longitud);
        
        Spider subcadena = from resultado ## 0 ## 5;  $$ "Notch"
        dropperSpider("Subcadena (0, 5): " bind subcadena);
        
        Spider sinNotch = except resultado ## 0 ## 6;  $$ "Engine"
        dropperSpider("Sin los primeros 6 caracteres: " bind sinNotch);
        
        Stack posicion = seek(resultado, "Engine");  $$ 6
        dropperSpider("Posición de 'Engine': " bind posicion);
        
        $$ Acceso a caracteres individuales
        Rune primerCaracter = resultado[0];    $$ 'N'
        dropperSpider("Primer carácter: ");
        dropperRune(primerCaracter);
        
        Rune ultimoCaracter = resultado[11];   $$ 'e'
        dropperSpider("Último carácter: ");
        dropperRune(ultimoCaracter);
        
        $$ Mostrar cadenas con secuencias de escape
        dropperSpider("Cadena con nueva línea:");
        dropperSpider(conNuevaLinea);
        
        dropperSpider("Cadena con tabulaciones:");
        dropperSpider(conTabulacion);
        
        dropperSpider("Cadena con comillas dobles:");
        dropperSpider(conComillasDobles);
        
        $$ Mostrar cadena larga
        dropperSpider("Cadena larga:");
        dropperSpider(cadenaLarga);
        
        $$ Verificar cadena vacía
        target cadenaVacia is "" craft hit
        PolloCrudo
            dropperSpider("La cadena está vacía");
        PolloAsado
        
        $$ Comparación de cadenas
        target SALUDO is "Hola Mundo" craft hit
        PolloCrudo
            dropperSpider("Las cadenas son iguales");
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba_Lit_Arreglos.ne
  Propósito: Verificar reconocimiento de literales de arreglos ([1, 2, 3, 4, 5])
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

$$ Prueba de literales de arreglos en NotchEngine
$$ Verificando: arreglos de diferentes tipos y dimensiones

WorldName PruebaLitArreglos:

Bedrock

    $$ Constantes de arreglos (no se permiten, solo como comentario)
    $$ Obsidian Shelf Stack NUMEROS [1, 2, 3, 4, 5];

Inventory

    $$ Arreglos de enteros
    Shelf[5] Stack numerosSimples = [1, 2, 3, 4, 5];
    Shelf[3] Stack numerosNegativos = [-10, -20, -30];
    Shelf[4] Stack numerosMixtos = [-2, 0, 2, 4];
    Shelf[1] Stack unicoElemento = [42];
    Shelf[0] Stack arregloVacio = [];
    
    $$ Arreglos de caracteres
    Shelf[5] Rune vocales = ['a', 'e', 'i', 'o', 'u'];
    Shelf[5] Rune simbolos = ['!', '@', '#', '$', '%'];
    
    $$ Arreglos de cadenas
    Shelf[3] Spider nombres = ["Steve", "Alex", "Herobrine"];
    Shelf[4] Spider diasSemana = ["Lunes", "Martes", "Miércoles", "Jueves"];
    
    $$ Arreglos de booleanos
    Shelf[4] Torch flags = [On, Off, On, On];
    
    $$ Arreglos de flotantes
    Shelf[3] Ghast decimales = [3.14, 2.71, 1.618];
    
    $$ Arreglos bidimensionales
    Shelf[3] Shelf[3] Stack matriz = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    $$ Arreglos tridimensionales
    Shelf[2] Shelf[2] Shelf[2] Stack cubo = [
        [
            [1, 2],
            [3, 4]
        ],
        [
            [5, 6],
            [7, 8]
        ]
    ];
    
    $$ Variables para resultados
    Stack suma = 0;
    Stack elementoActual = 0;

SpawnPoint

    PolloCrudo
        $$ Acceso a elementos de arreglos unidimensionales
        elementoActual = numerosSimples[0];  $$ 1
        dropperSpider("Primer elemento del arreglo: " bind elementoActual);
        
        elementoActual = numerosSimples[4];  $$ 5
        dropperSpider("Último elemento del arreglo: " bind elementoActual);
        
        $$ Modificación de elementos
        numerosSimples[2] = 30;  $$ Cambia el tercer elemento a 30
        dropperSpider("Elemento modificado: " bind numerosSimples[2]);
        
        $$ Recorrido de arreglo
        suma = 0;
        walk i set 0 to 4 craft
        PolloCrudo
            suma += numerosSimples[i];
            dropperSpider("Elemento " bind i bind ": " bind numerosSimples[i]);
        PolloAsado
        
        dropperSpider("Suma de todos los elementos: " bind suma);
        
        $$ Mostrar arreglo de caracteres
        dropperSpider("Vocales: ");
        walk i set 0 to 4 craft
        PolloCrudo
            dropperRune(vocales[i]);
        PolloAsado
        
        $$ Mostrar arreglo de cadenas
        dropperSpider("Nombres: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperSpider(nombres[i]);
        PolloAsado
        
        $$ Mostrar arreglo de booleanos
        dropperSpider("Flags: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperTorch(flags[i]);
        PolloAsado
        
        $$ Mostrar arreglo de flotantes
        dropperSpider("Decimales: ");
        walk i set 0 to 2 craft
        PolloCrudo
            dropperGhast(decimales[i]);
        PolloAsado
        
        $$ Acceso a elementos de matriz (arreglo bidimensional)
        elementoActual = matriz[1][1];  $$ 5 (elemento central)
        dropperSpider("Elemento central de la matriz: " bind elementoActual);
        
        $$ Modificar elemento de matriz
        matriz[0][2] = 10;  $$ Modifica el elemento (0,2)
        dropperSpider("Elemento modificado de la matriz: " bind matriz[0][2]);
        
        $$ Mostrar matriz completa
        dropperSpider("Matriz completa:");
        walk i set 0 to 2 craft
        PolloCrudo
            walk j set 0 to 2 craft
            PolloCrudo
                dropperStack(matriz[i][j]);
            PolloAsado
            dropperSpider(""); $$ Nueva línea
        PolloAsado
        
        $$ Acceso a elemento de arreglo tridimensional
        elementoActual = cubo[1][0][1];  $$ 6
        dropperSpider("Elemento de cubo [1][0][1]: " bind elementoActual);
        
        $$ Inicialización de arreglos en línea dentro del código
        Shelf[4] Stack fibonacci = [1, 1, 2, 3];
        dropperSpider("Fibonacci: ");
        walk i set 0 to 3 craft
        PolloCrudo
            dropperStack(fibonacci[i]);
        PolloAsado
    PolloAsado

worldSave

$* 
  14_Prueba_Lit_Registros.ne
  Propósito: Verificar el reconocimiento de literales de registros en Notch Engine
  Probar: Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitRegistros:

Inventory

    $$ Declaración de tipos de entidades
    Entity Jugador 
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;

    Entity Coordenada 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Configuracion 
    PolloCrudo
        Torch modoDebug;
        Stack volumen;
        Spider idioma;
    PolloAsado;

    $$ Asignación con literales de registro simples
    Entity Jugador steve = {nombre: "Steve", nivel: 1, salud: 20.0, activo: On};
    Entity Jugador alex = {nombre: "Alex", nivel: 2, salud: 18.5, activo: On};

    $$ Registro con valores numéricos
    Entity Coordenada posicion = {x: 10, y: 20, z: 30};
    
    $$ Registro con valores mixtos
    Entity Configuracion config = {modoDebug: Off, volumen: 75, idioma: "Español"};
    
    $$ Registro vacío
    Entity Jugador jugadorVacio = {};
    
    $$ Registro con un solo campo
    Entity Coordenada origen = {x: 0};
    
    $$ Registro con expresiones
    Entity Coordenada punto = {x: 5 + 5, y: 10 * 2, z: 100 // 2};
    
    $$ Registro con registros anidados no es válido en Notch Engine,
    $$ por lo que no se incluye en esta prueba

SpawnPoint

    PolloCrudo
        $$ Acceso a los campos del registro
        dropperSpider(steve@nombre);
        dropperStack(posicion@x);
        dropperTorch(config@modoDebug);
        
        $$ Modificación de campos
        steve@nivel = 5;
        posicion@z = 50;
        
        $$ Operaciones con campos
        Stack nivelTotal = steve@nivel + alex@nivel;
        dropperStack(nivelTotal);
        
        $$ Uso del operador wither para simplificar el acceso
        wither steve craft
        PolloCrudo
            dropperSpider("Nombre: " bind nombre);
            dropperStack(nivel);
            dropperGhast(salud);
        PolloAsado

        $$ Casos de prueba adicionales para el scanner
        Entity Jugador herobrine = {$$ Registro con comentario
            nombre: "Herobrine", 
            nivel: 100, 
            salud: 1000.0, 
            activo: On};
        
        $$ Registro con espacios variados en la sintaxis
        Entity Coordenada pos2 = {x: 100, y: 200, z: 300};
    PolloAsado

worldSave

$* 
  15_Prueba_Lit_Conjuntos.ne
  Propósito: Verificar el reconocimiento de literales de conjuntos en Notch Engine
  Probar: Stack, Rune, Spider, Torch, Chest, Book, Ghast, Shelf, Entity
  Fecha: 28/04/2025
*$

WorldName PruebaLitConjuntos:

Inventory

    $$ Conjuntos de valores enteros
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Chest primos = {: 2, 3, 5, 7, 11, 13, 17, 19 :};
    Chest pares = {: 2, 4, 6, 8, 10 :};
    
    $$ Conjuntos de caracteres
    Chest vocales = {: 'a', 'e', 'i', 'o', 'u' :};
    Chest consonantes = {: 'b', 'c', 'd', 'f', 'g' :};
    
    $$ Conjuntos de cadenas
    Chest nombres = {: "Steve", "Alex", "Herobrine", "Notch" :};
    Chest herramientas = {: "Espada", "Pico", "Hacha", "Pala" :};
    
    $$ Conjunto vacío
    Chest vacio = {: :};
    
    $$ Conjunto con un solo elemento
    Chest singleton = {: 42 :};
    
    $$ Conjuntos con tipos mixtos (no permitido en Notch Engine según la gramática,
    $$ pero útil como caso de prueba para el scanner)
    Chest mezcla = {: 1, 'a', "texto" :};
    
    $$ Conjuntos con expresiones
    Chest calculados = {: 1 + 1, 2 * 2, 10 // 2 :};
    
    $$ Conjuntos con literales booleanos
    Chest booleanos = {: On, Off :};

SpawnPoint

    PolloCrudo
        $$ Operaciones con conjuntos
        add(numeros, 6);
        dropperSpider("Después de add(numeros, 6):");
        
        drop(primos, 2);
        dropperSpider("Después de drop(primos, 2):");
        
        $$ Unión de conjuntos
        Chest union = feed(numeros, primos);
        dropperSpider("Unión de numeros y primos:");
        
        $$ Intersección de conjuntos
        Chest interseccion = map(numeros, pares);
        dropperSpider("Intersección de numeros y pares:");
        
        $$ Verificar pertenencia
        Torch contiene = biom(vocales, 'a');
        dropperTorch(contiene);
        
        $$ Verificar si un conjunto está vacío
        Torch esVacio = void(vacio);
        dropperTorch(esVacio);
        
        $$ Casos de prueba adicionales para el scanner
        Chest conEspacios = {:'a',  'b',    'c':};
        Chest conComentarios = {: 1, $$ Primer elemento
                                2, $$ Segundo elemento
                                3  $$ Último elemento
                             :};
        
        $$ Conjunto con sintaxis variada
        Chest{:1,'x',"y":};
    PolloAsado

worldSave

$* 
  16_Prueba_Lit_Archivos.ne
  Propósito: Verificar el reconocimiento de literales de archivos en Notch Engine
  Probar: Book, unlock, lock, make, gather, expand
  Fecha: 28/04/2025
*$

WorldName PruebaLitArchivos:

Inventory

    $$ Archivos en modo lectura
    Book archivoConfiguracion = {/ "config.txt", 'L' /};
    Book archivoJugadores = {/ "jugadores.dat", 'L' /};
    Book archivoNiveles = {/ "niveles/nivel1.map", 'L' /};
    
    $$ Archivos en modo escritura
    Book archivoLog = {/ "sistema.log", 'E' /};
    Book archivoResultados = {/ "resultados.txt", 'E' /};
    Book archivoExportacion = {/ "export/datos.csv", 'E' /};
    
    $$ Archivos en modo actualización
    Book archivoPuntajes = {/ "puntajes.dat", 'A' /};
    Book archivoInventario = {/ "inventario.sav", 'A' /};
    
    $$ Nombres de archivo con espacios y caracteres especiales
    Book archivoEspecial = {/ "archivo con espacios.txt", 'L' /};
    Book archivoEspecial2 = {/ "datos_especiales-2023.dat", 'E' /};
    
    $$ Rutas relativas y absolutas
    Book archivoRutaRelativa = {/ "../datos/config.ini", 'L' /};
    Book archivoRutaAbsoluta = {/ "C:/Notch/Engine/data.bin", 'E' /};
    
    $$ Nombres de archivo con extensiones varias
    Book archivoTexto = {/ "readme.txt", 'L' /};
    Book archivoImagen = {/ "textura.png", 'L' /};
    Book archivoJSON = {/ "settings.json", 'A' /};
    Book archivoXML = {/ "estructura.xml", 'A' /};
    
    $$ Casos para probar el scanner
    Book conBarras = {/ "dir/subdir/archivo.ext", 'L' /};
    Book conPuntos = {/ "../../archivo.ext", 'E' /};
    
    $$ Casos con espaciado variado
    Book espaciado1 = {/"compacto.txt",'L'/};
    Book espaciado2 = {/   "espacios.txt"  ,  'E'   /};
    
    $$ Con comentarios cerca
    Book comentado = {/ "log.txt", 'L' /}; $$ Archivo de log

SpawnPoint

    PolloCrudo
        $$ Operaciones con archivos
        
        $$ Abrir archivo
        unlock(archivoLog);
        
        $$ Escribir en archivo
        forge(archivoLog, "Entrada de log: Inicio de programa");
        
        $$ Cerrar archivo
        lock(archivoLog);
        
        $$ Crear nuevo archivo
        Book nuevoArchivo = make({/ "nuevo.txt", 'E' /});
        
        $$ Leer archivo
        unlock(archivoConfiguracion);
        Spider contenido = gather(archivoConfiguracion);
        lock(archivoConfiguracion);
        
        $$ Concatenar archivos
        expand(archivoLog, archivoResultados);
        
        $$ Casos adicionales para probar el scanner
        Book {/ "sinVariable.txt", 'A' /};
        
        $$ Con sintaxis de literales seguidos
        Book arch1 = {/ "uno.txt", 'L' /}; Book arch2 = {/ "dos.txt", 'E' /};
        
        $$ Con comentarios dentro
        Book conComentarioMedio = {/ $$ Este comentario no debería ser válido
            "comentado.txt", 'A' /};
    PolloAsado

worldSave

$* 
  17_Prueba_Op_Aritmeticos.ne
  Propósito: Verificar el reconocimiento de operadores aritméticos básicos en Notch Engine
  Probar: Stack, dropperSpider
  Fecha: 28/04/2025
*$

WorldName PruebaOpAritmeticos:

Inventory

    Stack a = 10;
    Stack b = 3;
    Stack c;
    Stack resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma (+)
        c = a + b;
        dropperSpider("Suma: " bind c);
        
        $$ Prueba operador de resta (-)
        c = a - b;
        dropperSpider("Resta: " bind c);
        
        $$ Prueba operador de multiplicación (*)
        c = a * b;
        dropperSpider("Multiplicación: " bind c);
        
        $$ Prueba operador de división entera (//)
        c = a // b;
        dropperSpider("División entera: " bind c);
        
        $$ Prueba operador de módulo (%)
        c = a % b;
        dropperSpider("Módulo: " bind c);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = a + b * c;
        dropperSpider("a + b * c = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = a + b + c;
        dropperSpider("a + b + c = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = a * b // c + a - b;
        dropperSpider("a * b // c + a - b = " bind resultado);
        
        $$ Operador unario menos
        resultado = -a;
        dropperSpider("-a = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5 + 3;
        dropperSpider("5 + 3 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(a + b);
        dropperSpider("-(a + b) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a+b;
        resultado = a-b;
        resultado = a*b;
        resultado = a//b;
        resultado = a%b;
        
        $$ Operadores con espacios variados
        resultado = a +  b;
        resultado = a  -b;
        resultado = a* b;
        resultado = a  //   b;
        resultado = a % b;
        
        $$ Operaciones con comentarios
        resultado = a + b; $$ Suma
        resultado = a $$ operando 1
                   * b; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((a + b) * c) // 2) % 10);
        
        $$ Operaciones con expresiones incremento/decremento
        soulsand a;
        resultado = a + b;
        magma b;
        resultado = a - b;
    PolloAsado

worldSave

$* 
  18_Prueba_Op_Flotantes.ne
  Propósito: Verificar el reconocimiento de operadores para números flotantes en Notch Engine
  Probar: Ghast
  Fecha: 28/04/2025
*$

WorldName PruebaOpFlotantes:

Inventory

    Ghast x = 10.5;
    Ghast y = 3.25;
    Ghast z;
    Ghast resultado;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de suma flotante (:+)
        z = x :+ y;
        dropperSpider("Suma flotante: " bind z);
        
        $$ Prueba operador de resta flotante (:-)
        z = x :- y;
        dropperSpider("Resta flotante: " bind z);
        
        $$ Prueba operador de multiplicación flotante (:*)
        z = x :* y;
        dropperSpider("Multiplicación flotante: " bind z);
        
        $$ Prueba operador de división flotante (://)
        z = x :// y;
        dropperSpider("División flotante: " bind z);
        
        $$ Prueba operador de módulo flotante (:%)
        z = x :% y;
        dropperSpider("Módulo flotante: " bind z);
        
        $$ Pruebas con expresiones más complejas
        
        $$ Operaciones combinadas
        resultado = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado);
        
        $$ Operaciones con paréntesis
        resultado = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado);
        
        $$ Operaciones encadenadas
        resultado = x :+ y :+ z;
        dropperSpider("x :+ y :+ z = " bind resultado);
        
        $$ Operaciones con múltiples operadores
        resultado = x :* y :// z :+ x :- y;
        dropperSpider("x :* y :// z :+ x :- y = " bind resultado);
        
        $$ Operador unario menos
        resultado = -x;
        dropperSpider("-x = " bind resultado);
        
        $$ Operaciones con literales
        resultado = 5.5 :+ 3.2;
        dropperSpider("5.5 :+ 3.2 = " bind resultado);
        
        $$ Operaciones con operador unario y paréntesis
        resultado = -(x :+ y);
        dropperSpider("-(x :+ y) = " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = x:+y;
        resultado = x:-y;
        resultado = x:*y;
        resultado = x://y;
        resultado = x:%y;
        
        $$ Operadores con espacios variados
        resultado = x :+  y;
        resultado = x  :-y;
        resultado = x:* y;
        resultado = x  ://   y;
        resultado = x :% y;
        
        $$ Operaciones con comentarios
        resultado = x :+ y; $$ Suma flotante
        resultado = x $$ operando 1
                   :* y; $$ operando 2
        
        $$ Casos extremos
        resultado = ((((x :+ y) :* z) :// 2.0) :% 10.0);
        
        $$ Mezcla con operadores enteros (para prueba de scanner)
        Ghast mezcla1 = x :+ 5;
        Ghast mezcla2 = 3.5 :* y;
        Ghast mezcla3 = x :+ (y :* 2.0) :// 1.5;
        
        $$ Casos de prueba adicionales
        
        $$ Operador : seguido de otros símbolos (verificar scanner)
        Spider texto = "Notch:Engine";
        
        $$ Operadores flotantes en expresiones con coherción
        Stack entero = (x :+ y) >> Stack;
    PolloAsado

worldSave

$* 
  19_Prueba_Op_Comparacion.ne
  Propósito: Verificar el reconocimiento de operadores de comparación en Notch Engine
  Probar: =, !=, <, >, <=, >=, is, isNot
  Fecha: 28/04/2025
*$

WorldName PruebaOpComparacion:

Inventory

    Stack a = 10;
    Stack b = 5;
    Torch resultado;
    
    Ghast x = 3.5;
    Ghast y = 2.75;
    
    Spider cadena1 = "abc";
    Spider cadena2 = "def";
    
    Rune char1 = 'A';
    Rune char2 = 'B';
    
    Torch bool1 = On;
    Torch bool2 = Off;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador menor que (<)
        resultado = a < b;
        dropperSpider("a < b: " bind resultado);
        
        resultado = x < y;
        dropperSpider("x < y: " bind resultado);
        
        resultado = cadena1 < cadena2;
        dropperSpider("cadena1 < cadena2: " bind resultado);
        
        resultado = char1 < char2;
        dropperSpider("char1 < char2: " bind resultado);
        
        $$ Pruebas con operador mayor que (>)
        resultado = a > b;
        dropperSpider("a > b: " bind resultado);
        
        resultado = x > y;
        dropperSpider("x > y: " bind resultado);
        
        $$ Pruebas con operador menor o igual que (<=)
        resultado = a <= b;
        dropperSpider("a <= b: " bind resultado);
        
        resultado = x <= y;
        dropperSpider("x <= y: " bind resultado);
        
        $$ Pruebas con operador mayor o igual que (>=)
        resultado = a >= b;
        dropperSpider("a >= b: " bind resultado);
        
        resultado = x >= y;
        dropperSpider("x >= y: " bind resultado);
        
        $$ Pruebas con operador igual a (is)
        resultado = a is b;
        dropperSpider("a is b: " bind resultado);
        
        resultado = x is y;
        dropperSpider("x is y: " bind resultado);
        
        resultado = cadena1 is cadena2;
        dropperSpider("cadena1 is cadena2: " bind resultado);
        
        resultado = bool1 is bool2;
        dropperSpider("bool1 is bool2: " bind resultado);
        
        $$ Pruebas con operador distinto de (isNot)
        resultado = a isNot b;
        dropperSpider("a isNot b: " bind resultado);
        
        resultado = x isNot y;
        dropperSpider("x isNot y: " bind resultado);
        
        resultado = cadena1 isNot cadena2;
        dropperSpider("cadena1 isNot cadena2: " bind resultado);
        
        resultado = bool1 isNot bool2;
        dropperSpider("bool1 isNot bool2: " bind resultado);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        resultado = a<b;
        resultado = a>b;
        resultado = a<=b;
        resultado = a>=b;
        resultado = aisb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a is b;
        resultado = aisNotb;  $$ Este caso debería ser un identificador, no un operador
        resultado = a isNot b;
        
        $$ Operadores con espacios variados
        resultado = a <  b;
        resultado = a  > b;
        resultado = a<=  b;
        resultado = a  >= b;
        resultado = a  is  b;
        resultado = a  isNot  b;
        
        $$ Operaciones de comparación en expresiones condicionales
        target a < b craft hit
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        
        repeater x > y craft
        PolloCrudo
            dropperSpider("x es mayor que y");
        PolloAsado
        
        $$ Operaciones de comparación con expresiones
        resultado = (a + b) > (x :+ y);
        resultado = a * 2 <= b * 3;
        resultado = (a // 2) is (b // 1);
        resultado = bind(cadena1, cadena2) isNot "abcdef";
        
        $$ Operador 'is' y 'isNot' en diferentes contextos (verificar scanner)
        Spider islandia = "país"; $$ Identificador que comienza con 'is'
        Stack isNotacion = 42;    $$ Identificador que comienza con 'isNot'
    PolloAsado

worldSave

$* 
  20_Prueba_Op_Asignacion.ne
  Propósito: Verificar el reconocimiento de operadores de asignación en Notch Engine
  Fecha: 28/04/2025
  Operadores: =, +=, -=, *=, /=, %=
*$

WorldName PruebaOpAsignacion:

Inventory

    Stack contador = 10;
    Stack acumulador = 0;
    
    Ghast decimal = 5.5;
    
    Spider texto = "Notch";
    
    Shelf[5] Stack arreglo;
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Prueba operador de asignación simple (=)
        contador = 5;
        dropperSpider("Asignación simple: " bind contador);
        
        decimal = 3.14;
        texto = "Engine";
        
        $$ Prueba operador de asignación con suma (+=)
        contador += 3;
        dropperSpider("Asignación con suma: " bind contador);
        
        acumulador = 0;
        acumulador += contador;
        acumulador += 2;
        dropperSpider("Acumulador después de += : " bind acumulador);
        
        $$ Prueba operador de asignación con resta (-=)
        contador -= 2;
        dropperSpider("Asignación con resta: " bind contador);
        
        acumulador = 20;
        acumulador -= 5;
        acumulador -= contador;
        dropperSpider("Acumulador después de -= : " bind acumulador);
        
        $$ Prueba operador de asignación con multiplicación (*=)
        contador *= 3;
        dropperSpider("Asignación con multiplicación: " bind contador);
        
        acumulador = 2;
        acumulador *= contador;
        dropperSpider("Acumulador después de *= : " bind acumulador);
        
        $$ Prueba operador de asignación con división (/=)
        contador /= 2;
        dropperSpider("Asignación con división: " bind contador);
        
        acumulador = 50;
        acumulador /= 5;
        dropperSpider("Acumulador después de /= : " bind acumulador);
        
        $$ Prueba operador de asignación con módulo (%=)
        contador %= 3;
        dropperSpider("Asignación con módulo: " bind contador);
        
        acumulador = 17;
        acumulador %= 5;
        dropperSpider("Acumulador después de %= : " bind acumulador);
        
        $$ Prueba de asignaciones a elementos de arreglos
        arreglo[0] = 10;
        arreglo[1] = 20;
        arreglo[2] = 30;
        
        arreglo[0] += 5;
        dropperSpider("arreglo[0] después de += : " bind arreglo[0]);
        
        arreglo[1] -= 5;
        dropperSpider("arreglo[1] después de -= : " bind arreglo[1]);
        
        arreglo[2] *= 2;
        dropperSpider("arreglo[2] después de *= : " bind arreglo[2]);
        
        $$ Prueba de asignaciones a campos de registros
        punto@x = 10;
        punto@y = 20;
        
        punto@x += 5;
        dropperSpider("punto@x después de += : " bind punto@x);
        
        punto@y -= 8;
        dropperSpider("punto@y después de -= : " bind punto@y);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        contador=5;
        contador+=3;
        contador-=2;
        contador*=4;
        contador/=2;
        contador%=3;
        
        $$ Operadores con espacios variados
        contador =  5;
        contador +=  3;
        contador  -= 2;
        contador *= 4;
        contador  /=  2;
        contador  %=   3;
        
        $$ Operaciones con comentarios
        contador = 10; $$ Asignación con comentario
        contador += $$ Comentario en medio
                    5;
        
        $$ Asignaciones múltiples
        Stack a = 1, b = 2, c = 3;
        
        $$ Asignaciones con expresiones
        contador = (a + b) * c;
        contador += a * b;
        contador -= a + b;
        contador *= (a * 2) + (b * 3);
        contador /= a + 1;
        contador %= b * 2;
        
        $$ Asignaciones múltiples en una sola línea
        a = 10; b = 20; c = 30;
        
        $$ Casos con posibles confusiones para el scanner
        Spider igual_texto = "Este texto tiene un signo = dentro";
        Spider mas_texto = "Este texto tiene un signo + dentro";
        Spider menos_texto = "Este texto tiene un signo - dentro";
        Spider por_texto = "Este texto tiene un signo * dentro";
        Spider div_texto = "Este texto tiene un signo / dentro";
        Spider mod_texto = "Este texto tiene un signo % dentro";
    PolloAsado

worldSave

$* 
  21_Prueba_Op_Acceso.ne
  Propósito: Verificar el reconocimiento de operadores de acceso a estructuras de datos en Notch Engine
  Fecha: 28/04/2025
  Operadores: [i][j], string[i], registro@campo
*$

WorldName PruebaOpAcceso:

Inventory

    $$ Declaración de arreglos
    Shelf[5] Stack numeros;
    Shelf[3] Shelf[3] matriz;
    Shelf[2] Shelf[2] Shelf[2] cubo;
    
    $$ Declaración de strings
    Spider texto = "Notch Engine";
    
    $$ Declaración de registros
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    Entity Punto punto;
    
    Entity Persona 
    PolloCrudo
        Spider nombre;
        Stack edad;
        Torch activo;
        Shelf[3] Stack notas;
    PolloAsado;
    
    Entity Persona estudiante;
    
    $$ Arreglo de registros
    Shelf[3] Entity Punto puntos;
    
    $$ Registro con arreglos
    Entity Contenedor 
    PolloCrudo
        Shelf[5] Stack valores;
        Spider etiqueta;
    PolloAsado;
    
    Entity Contenedor caja;

SpawnPoint

    PolloCrudo
        $$ Pruebas de acceso a arreglos unidimensionales
        numeros[0] = 10;
        numeros[1] = 20;
        numeros[2] = 30;
        
        Stack valor = numeros[0];
        dropperSpider("Valor en numeros[0]: " bind valor);
        
        $$ Acceso con expresiones como índices
        Stack indice = 2;
        valor = numeros[indice];
        dropperSpider("Valor en numeros[indice]: " bind valor);
        
        valor = numeros[1 + 1];
        dropperSpider("Valor en numeros[1 + 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos multidimensionales
        matriz[0][0] = 11;
        matriz[0][1] = 12;
        matriz[1][0] = 21;
        matriz[1][1] = 22;
        
        valor = matriz[1][1];
        dropperSpider("Valor en matriz[1][1]: " bind valor);
        
        $$ Acceso con expresiones como índices
        valor = matriz[indice - 1][indice - 1];
        dropperSpider("Valor en matriz[indice - 1][indice - 1]: " bind valor);
        
        $$ Pruebas de acceso a arreglos tridimensionales
        cubo[0][0][0] = 111;
        cubo[1][1][1] = 222;
        
        valor = cubo[1][1][1];
        dropperSpider("Valor en cubo[1][1][1]: " bind valor);
        
        $$ Pruebas de acceso a caracteres en strings
        Rune caracter = texto[0];
        dropperSpider("Carácter en texto[0]: " bind caracter);
        
        caracter = texto[6];
        dropperSpider("Carácter en texto[6]: " bind caracter);
        
        $$ Acceso con expresiones como índices
        caracter = texto[indice * 2];
        dropperSpider("Carácter en texto[indice * 2]: " bind caracter);
        
        $$ Modificación de caracteres en strings
        texto[0] = 'n';
        dropperSpider("Texto modificado: " bind texto);
        
        $$ Pruebas de acceso a campos de registros
        punto@x = 10;
        punto@y = 20;
        punto@z = 30;
        
        valor = punto@x;
        dropperSpider("Valor en punto@x: " bind valor);
        
        punto@y = punto@x * 2;
        dropperSpider("Valor en punto@y después de asignación: " bind punto@y);
        
        $$ Acceso a campos de registros más complejos
        estudiante@nombre = "Steve";
        estudiante@edad = 25;
        estudiante@activo = On;
        estudiante@notas[0] = 85;
        estudiante@notas[1] = 90;
        estudiante@notas[2] = 95;
        
        Spider nombre = estudiante@nombre;
        dropperSpider("Nombre del estudiante: " bind nombre);
        
        Stack nota = estudiante@notas[1];
        dropperSpider("Segunda nota del estudiante: " bind nota);
        
        $$ Pruebas de acceso a arreglos de registros
        puntos[0]@x = 1;
        puntos[0]@y = 2;
        puntos[0]@z = 3;
        
        puntos[1]@x = 4;
        puntos[1]@y = 5;
        puntos[1]@z = 6;
        
        valor = puntos[1]@y;
        dropperSpider("Valor en puntos[1]@y: " bind valor);
        
        $$ Pruebas de acceso a registros con arreglos
        caja@etiqueta = "Items";
        caja@valores[0] = 100;
        caja@valores[1] = 200;
        
        valor = caja@valores[1];
        dropperSpider("Valor en caja@valores[1]: " bind valor);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios entre operando y operador
        valor =numeros[0];
        nombre =estudiante@nombre;
        
        $$ Operadores con espacios variados
        valor = numeros [0];
        valor = matriz [1] [1];
        nombre = estudiante @ nombre;
        
        $$ Accesos encadenados complejos
        valor = cubo[0][matriz[0][0] % 3][numeros[0] // 10];
        
        $$ Accesos con comentarios intercalados
        valor = numeros $$ Comentario en medio
               [0];
        
        nombre = estudiante $$ Comentario en medio
                 @nombre;
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoCuadrado = "Esto no es un [acceso]";
        Spider textoArroba = "Email: usuario@dominio.com";
    PolloAsado

worldSave

$* 
  22_Prueba_Op_Especiales.ne
  Propósito: Verificar el reconocimiento de operadores especiales en Notch Engine
  Fecha: 28/04/2025
  Operadores: chunk (size of), >> (coherción de tipos)
*$

WorldName PruebaOpEspeciales:

Bedrock

    Obsidian Stack MAX_SIZE 1024;

Inventory

    $$ Declaración de variables de diferentes tipos
    Stack entero = 42;
    Ghast flotante = 3.14159;
    Spider texto = "Notch Engine";
    Rune caracter = 'A';
    Torch booleano = On;
    
    $$ Estructuras de datos
    Shelf[5] Stack arreglo;
    Chest conjunto = {: 1, 2, 3 :};
    
    Entity Punto 
    PolloCrudo
        Stack x;
        Stack y;
    PolloAsado;
    
    Entity Punto punto;

SpawnPoint

    PolloCrudo
        $$ Pruebas con operador chunk (size of)
        
        $$ Tamaño de tipos básicos
        Stack tamanoStack = chunk Stack;
        Stack tamanoGhast = chunk Ghast;
        Stack tamanoSpider = chunk Spider;
        Stack tamanoRune = chunk Rune;
        Stack tamanoTorch = chunk Torch;
        
        dropperSpider("Tamaño de Stack en bytes: " bind tamanoStack);
        dropperSpider("Tamaño de Ghast en bytes: " bind tamanoGhast);
        dropperSpider("Tamaño de Spider en bytes: " bind tamanoSpider);
        dropperSpider("Tamaño de Rune en bytes: " bind tamanoRune);
        dropperSpider("Tamaño de Torch en bytes: " bind tamanoTorch);
        
        $$ Tamaño de tipos compuestos
        Stack tamanoShelf = chunk Shelf[5] Stack;
        Stack tamanoChest = chunk Chest;
        Stack tamanoPunto = chunk Punto;
        
        dropperSpider("Tamaño de arreglo en bytes: " bind tamanoShelf);
        dropperSpider("Tamaño de conjunto en bytes: " bind tamanoChest);
        dropperSpider("Tamaño de Punto en bytes: " bind tamanoPunto);
        
        $$ Tamaño de variables
        Stack tamanoVariable = chunk entero;
        Stack tamanoArreglo = chunk arreglo;
        Stack tamanoTexto = chunk texto;
        
        dropperSpider("Tamaño de variable entero en bytes: " bind tamanoVariable);
        dropperSpider("Tamaño de variable arreglo en bytes: " bind tamanoArreglo);
        dropperSpider("Tamaño de variable texto en bytes: " bind tamanoTexto);
        
        $$ Tamaño de expresiones
        Stack tamanoExpresion = chunk (entero * 2 + 10);
        dropperSpider("Tamaño de expresión en bytes: " bind tamanoExpresion);
        
        $$ Pruebas con operador >> (coherción de tipos)
        
        $$ Coherción de Ghast a Stack
        Stack enteroDeFlotante = flotante >> Stack;
        dropperSpider("Flotante convertido a entero: " bind enteroDeFlotante);
        
        $$ Coherción de Stack a Torch
        Torch booleanoDeEntero = entero >> Torch;
        dropperSpider("Entero convertido a booleano: " bind booleanoDeEntero);
        
        $$ Coherción de Spider a Rune
        Rune caracterDeTexto = texto >> Rune;
        dropperSpider("Primer carácter del texto: " bind caracterDeTexto);
        
        $$ Coherción de expresiones
        Stack resultadoEntero = (flotante :+ 2.5) >> Stack;
        dropperSpider("Suma flotante convertida a entero: " bind resultadoEntero);
        
        $$ Casos especiales para probar el scanner
        
        $$ Operadores sin espacios
        Stack tam1 = chunkStack;        $$ Esto debería ser un identificador
        Stack tam2 = chunk Stack;       $$ Esto es correcto
        Stack tam3 = chunk(Stack);      $$ Esto podría ser problemático
        
        Stack ent1 = flotante>>Stack;   $$ Sin espacios
        Stack ent2 = flotante >> Stack; $$ Con espacios
        
        $$ Operadores con espacios variados
        Stack tam4 = chunk  Stack;
        Stack ent3 = flotante  >>  Stack;
        
        $$ Operaciones con comentarios
        Stack tam5 = chunk $$ Comentario en medio
                     Stack;
        
        Stack ent4 = flotante $$ Comentario en medio
                    >> Stack;
        
        $$ Combinaciones de ambos operadores
        Stack tamCombinado = chunk (flotante >> Stack);
        
        $$ Casos con posibles confusiones para el scanner
        Spider textoMayor = "Esto no es una coherción >>";
        Spider textoChunk = "La palabra chunk no es un operador aquí";
        
        $$ Uso en expresiones más complejas
        Stack resultado = (flotante :* 2.0 >> Stack) + (entero * 3);
        
        $$ Uso en estructuras de control
        target (flotante >> Stack) > 3 craft hit
        PolloCrudo
            dropperSpider("La parte entera de flotante es mayor que 3");
        PolloAsado
    PolloAsado

worldSave

$* 
  23_Prueba_Com_Linea.ne
  Propósito: Verificar el reconocimiento de comentarios de línea en Notch Engine
  Fecha: 28/04/2025
  Sintaxis: $$ comentario
*$

WorldName PruebaComLinea:

$$ Este es un comentario de línea al inicio del archivo

Bedrock

    $$ Comentario dentro de la sección de constantes
    Obsidian Stack MAX_LEVEL 100; $$ Comentario después de una constante
    $$ Comentario antes de una constante
    Obsidian Spider VERSION "1.0";

Inventory

    $$ Comentario al inicio de la sección de variables
    Stack contador = 0; $$ Inicialización del contador
    
    $$ Comentario antes de una declaración
    Spider texto = "Notch Engine"; $$ Nombre del motor
    
    Rune inicial; $$ Declaración simple con comentario
    
    $$ Múltiples comentarios
    $$ seguidos
    $$ de
    $$ líneas
    
    Stack a = 10, $$ Comentario entre declaraciones múltiples
          b = 20;
    
    $$ Comentarios con caracteres especiales: !@#$%^&*()_+-=[]{}|;:'",.<>/?
    $$ Comentarios con números: 1234567890
    $$ Comentarios con espacios en blanco:     espacios    tabulaciones	tabulaciones

Recipe

    $$ Comentario en sección de prototipos
    Spell calcular(Stack :: a, b) -> Stack; $$ Prototipo de función con comentario

CraftingTable

    $$ Comentario al inicio de la sección de rutinas
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $$ Comentario dentro de un bloque de función
        Stack resultado = a + b; $$ Cálculo simple
        respawn resultado; $$ Retornar el resultado
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $$ Comentario al inicio de un procedimiento
        dropperSpider(mensaje); $$ Mostrar el mensaje
    PolloAsado $$ Comentario al final de un bloque

SpawnPoint

    PolloCrudo
        $$ Comentario al inicio del punto de entrada
        
        $$ Comentario antes de una instrucción
        contador = 5; $$ Asignación con comentario
        
        $$ Comentario antes de estructura de control
        target contador > 0 craft hit
        PolloCrudo
            $$ Comentario dentro de estructura de control
            dropperSpider("Contador positivo"); $$ Mensaje
        PolloAsado
        
        $$ Prueba de comentarios en expresiones
        Stack resultado = contador $$ Comentario en medio de una expresión
                        + 10;
        
        $$ Comentarios en llamadas a funciones/procedimientos
        Stack suma = calcular(5 $$ Comentario en medio de argumentos
                           , 10);
        
        $$ Comentario antes de una instrucción nula
        ; $$ Comentario después de una instrucción nula
        
        $$ Comentarios con símbolos de operadores: + - * / % < > <= >= is isNot and or not
        $$ Comentarios con palabras reservadas: PolloCrudo PolloAsado repeater craft target
        
        $$ Comentario con símbolos que podrían confundirse con inicio de comentario de bloque
        $$ Este comentario tiene $* dentro pero no debería iniciar un comentario de bloque
        
        $$ Comentario con símbolos que podrían confundirse con fin de comentario de bloque
        $$ Este comentario tiene *$ dentro pero no debería cerrar nada
        
        $$ Comentario al final de una sección
    PolloAsado

$$ Comentario antes del cierre del programa

worldSave $$ Comentario después del cierre del programa

$$ Comentario después de todo el programa

$* 
  24_Prueba_Com_Bloque.ne
  Propósito: Verificar el reconocimiento de comentarios de bloque en Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaComBloque:

$* Este es un comentario de bloque 
   al inicio del archivo
   que ocupa varias líneas *$

Bedrock

    $* Comentario de bloque 
       dentro de la sección de constantes *$
    Obsidian Stack MAX_LEVEL 100;
    Obsidian Spider VERSION $* Comentario en medio de una declaración *$ "1.0";

Inventory

    $* 
    Comentario de bloque al inicio
    de la sección de variables 
    *$
    
    Stack contador = $* Comentario en medio de una asignación *$ 0;
    
    $* Comentario
       antes de
       una declaración *$
    Spider texto = "Notch Engine";
    
    Rune inicial; $* Comentario de bloque después de una declaración *$
    
    $* Comentario de bloque con caracteres especiales:
       !@#$%^&*()_+-=[]{}|;:'",.<>/?
       Números: 1234567890
       Palabras reservadas: PolloCrudo PolloAsado repeater craft target
       Operadores: + - * / % < > <= >= is isNot and or not
    *$
    
    $* Comentario con saltos
    
    de
    
    línea *$
    
    Stack a = 10, $* Comentario entre
                     declaraciones
                     múltiples *$ b = 20;
    
    $* Comentario con tabulaciones
    	Línea con tabulación
    		Línea con doble tabulación
    *$

Recipe

    $* Comentario de bloque
       en sección de prototipos *$
    Spell calcular(Stack :: a, b) -> Stack;

CraftingTable

    $* Comentario de bloque al inicio de la sección de rutinas *$
    
    Spell calcular(Stack :: a, b) -> Stack
    PolloCrudo
        $* Comentario de bloque
           dentro de un bloque de función *$
        Stack resultado = a + b;
        respawn resultado;
    PolloAsado
    
    Ritual mostrarMensaje(Spider :: mensaje)
    PolloCrudo
        $* Comentario al inicio
           de un procedimiento *$
        dropperSpider(mensaje);
    PolloAsado $* Comentario de bloque al final de un bloque *$

SpawnPoint

    PolloCrudo
        $* Comentario de bloque 
           al inicio del punto de entrada *$
        
        contador = 5 $* Comentario en medio
                        de una expresión *$ + 10;
        
        target contador > $* Comentario dentro
                             de una condición *$ 0 craft hit
        PolloCrudo
            dropperSpider("Contador positivo");
        PolloAsado
        
        $* Casos especiales para probar el scanner *$
        
        $* Comentario con símbolo $ dentro *$
        
        $* Comentario con símbolo * dentro *$
        
        $* Comentario con la secuencia *$ dentro pero sin cerrar aún *$
        
        $* Comentario con la secuencia $* dentro pero sin iniciar uno nuevo *$
        
        $* Comentario con múltiples
            $* estos no deberían iniciar
               nuevos comentarios *$
            secuencias $* anidadas *$
        *$
        
        $* Comentario con
           múltiples líneas
           
           y líneas en blanco
           
           y más contenido
        *$
        
        $* Comentario justo antes de un comentario de línea *$ $$ Comentario de línea
        
        $* 
           Comentario muy largo para probar límites del buffer
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
           ........................................................................
        *$
    PolloAsado

$* Comentario de bloque 
   antes del cierre del programa *$

worldSave $* Comentario de bloque después del cierre del programa *$

$* Comentario de bloque después de todo el programa *$

$* 
  25_Prueba_Com_Anidados.ne
  Prueba de comentarios de bloque con contenido complejo
  Para el analizador léxico de Notch Engine

  
  A continuación elementos que el analizador debe considerar como texto
  dentro del comentario y no como tokens independientes:
  
  - Palabras reservadas: WorldName Bedrock Inventory SpawnPoint CraftingTable
  - Operadores: +, -, *, //, %, and, or, not
  - Identificadores: contador, nombre, valor_x
  - Literales: "cadena de texto", 'c', 123, 45.67, On, Off
  - Símbolos: {, }, (, ), [, ], ;, :, @
  
  $ $ Esto no es un comentario de línea dentro del bloque
  
  Líneas con caracteres especiales:
  !@#$%^&*()_+-=[]{}|;:'",.<>/?`~
  
  Múltiples líneas vacías:
  
  
  
  Lineas con espacios en blanco:
           
  
  Un código que debería ser ignorado:
  
  WorldName PruebaIgnorada:
  Inventory {
    Stack contador = 123;
    Torch activo = On;
  }
  SpawnPoint {
    dropperSpider("Esto será ignorado");
  }
  worldSave
*$

$* Este es un comentario normal *$

$$ Comentario de línea después de un comentario de bloque

WorldName PruebaComentarios:

$* Comentario 
   multilínea
   para probar *$

Inventory

  $* Comentario dentro
     de una sección *$
  Stack contador = 10; $$ Comentario al final de la línea
  
  $* Otro
     comentario
     de múltiples
     líneas *$
  
  Spider texto = "Comentario /* falso */ dentro de un string";
  Rune caracter = '*'; $$ Carácter que podría confundirse con comentario

SpawnPoint

  PolloCrudo
    $* Comentario con símbolos +, -, *, /, %, <, >, <=, >=, is, isNot
       y otros caracteres especiales !@#$^&()_=[]{}|;:'",.<>/?`~ *$
    
    dropperSpider("Los comentarios son importantes");
    
    $$ Comentario que parece tener $* bloque *$ pero es de línea
  PolloAsado

worldSave

$* 
  26_Prueba_ID_Simples.ne
  Prueba de identificadores simples (una sola palabra)
  para el analizador léxico de Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimples:

Bedrock

  Obsidian Stack MAX 100;
  Obsidian Spider TITULO "Notch Engine";

Inventory

  $$ Identificadores de una sola palabra
  Stack a;
  Stack contador;
  Stack nivel;
  Stack x;
  Stack y;
  Stack z;
  Stack posicion;
  Stack altura;
  Stack ancho;
  
  Spider nombre;
  Spider texto;
  Spider mensaje;
  Spider saludo;
  
  Torch activo;
  Torch visible;
  Torch terminado;
  
  Rune inicial;
  Rune caracter;
  Rune simbolo;
  
  Ghast pi;
  Ghast temperatura;
  Ghast velocidad;
  
  $$ Identificadores que comienzan con letras mayúsculas
  Stack Contador;
  Spider Nombre;
  Torch Activo;
  
  $$ Identificadores cortos
  Stack i;
  Stack j;
  Stack k;
  Rune c;
  Spider s;
  Torch b;
  Ghast f;

CraftingTable

  Spell suma(Stack :: a, b) -> Stack
  PolloCrudo
    Stack resultado;
    resultado = a + b;
    respawn resultado;
  PolloAsado
  
  Ritual imprimir(Spider :: mensaje)
  PolloCrudo
    dropperSpider(mensaje);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores en expresiones
    Stack valor;
    Stack resultado;
    Spider mensaje;
    
    $$ Asignaciones simples
    valor = 10;
    mensaje = "Hola";
    
    $$ Operaciones con identificadores
    resultado = valor + 5;
    valor = suma(valor, 20);
    
    ender_pearl imprimir(mensaje);
  PolloAsado

worldSave

$* 
  Prueba_ID_Complejos.ne
  Propósito: Verificar identificadores complejos (con guiones bajos, números)
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresComplejos:

Bedrock

  Obsidian Stack MAX_LEVEL 100;
  Obsidian Stack MIN_LEVEL 1;
  Obsidian Spider GAME_TITLE "Notch Engine";
  Obsidian Spider VERSION_1_0 "v1.0";

Inventory

  $$ Identificadores con guiones bajos
  Stack player_level;
  Stack enemy_count;
  Stack max_health;
  Stack min_damage;
  Stack current_position_x;
  
  $$ Identificadores con números
  Stack counter1;
  Stack item2;
  Stack level3d;
  Stack position2d;
  Stack player1_health;
  
  $$ Identificadores mixtos con guiones bajos y números
  Stack item_1;
  Stack player_2_score;
  Stack enemy_level_3;
  Stack position_x_1;
  Stack inventory_slot_5;
  
  $$ Identificadores que comienzan con guión bajo
  Stack _temp;
  Stack _internal_counter;
  Stack _system_value;
  Stack _player_data;
  
  $$ Identificadores largos
  Stack very_long_variable_name_with_many_words;
  Spider extremely_long_message_text_that_describes_something_in_detail;
  Torch is_player_currently_in_creative_mode_with_flight_enabled;
  
  $$ Combinaciones variadas
  Stack player5_current_health_max_100;
  Stack enemy_3d_position_coordinate_x_12;
  Rune player_initial_1;
  Spider user_5_name;

CraftingTable

  Spell calculate_total_damage(Stack :: base_damage, critical_multiplier; Torch :: is_headshot) -> Stack
  PolloCrudo
    Stack total_damage;
    total_damage = base_damage * critical_multiplier;
    
    target is_headshot craft hit
    PolloCrudo
      total_damage = total_damage * 2;
    PolloAsado
    
    respawn total_damage;
  PolloAsado
  
  Ritual display_player_stats(Spider :: player_name; Stack level_1, health_points_100)
  PolloCrudo
    dropperSpider("Player: " bind player_name);
    dropperSpider("Level: " bind level_1);
    dropperSpider("Health: " bind health_points_100);
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Uso de identificadores complejos
    Stack player1_health = 100;
    Stack enemy_count_5 = 10;
    Spider main_player_name = "Steve_123";
    
    $$ Asignaciones y operaciones
    player1_health = player1_health - 20;
    enemy_count_5 = calculate_total_damage(10, 2, On);
    
    $$ Llamada a procedimiento
    ender_pearl display_player_stats(main_player_name, 5, player1_health);
    
    $$ Variables con guiones bajos múltiples
    Stack ___special_value = 42;
    dropperStack(___special_value);
  PolloAsado

worldSave

$* 
  Prueba_ID_Similares.ne
  Propósito: Verificar identificadores similares a palabras reservadas
  Fecha: 28/04/2025
*$

WorldName PruebaIdentificadoresSimilares:

Bedrock

  Obsidian Stack WorldNameTest 100;
  Obsidian Spider BedrockType "Hard Stone";
  Obsidian Torch InventoryFull On;

Inventory

  $$ Identificadores que son similares a palabras reservadas
  Stack worldname;
  Stack WorldName2;
  Stack bedrock;
  Stack Bedrock_Type;
  Stack inventory;
  Stack InventorySlot;
  Stack recipe;
  Stack RecipeBook;
  Stack craftingtable;
  Stack CraftingTable2;
  Stack spawnpoint;
  Stack SpawnPoint_Main;
  
  $$ Tipo de datos
  Stack stack;
  Spider spider;
  Torch torch;
  Rune rune;
  Ghast ghast;
  Chest chest;
  Book book;
  
  $$ Palabras reservadas para bloques
  Stack pollocrudo;
  Stack PolloAsado;
  Stack polloAsadoExtra;
  
  $$ Palabras reservadas para estructuras de control
  Stack repeater;
  Stack target;
  Stack hit;
  Stack miss;
  Stack craft;
  Stack jukebox;
  Stack disc;
  Stack silence;
  Stack spawner;
  Stack exhausted;
  Stack walk;
  Stack set;
  Stack to;
  Stack step;
  Stack wither;
  
  $$ Palabras reservadas para saltos
  Stack creeper;
  Stack enderPearl;
  Stack enderpearlitem;
  Stack ragequit;
  
  $$ Palabras reservadas para funciones
  Stack spell;
  Stack Spell_Cast;
  Stack ritual;
  Stack RitualCeremony;
  Stack respawn;
  Stack respawnPoint;
  Stack ender_pearl;
  Stack enderpearlTeleport;
  
  $$ Palabras reservadas para operadores
  Stack soulsand;
  Stack SoulSandBlock;
  Stack magma;
  Stack MagmaBlock;
  Stack and;
  Stack andOperator;
  Stack or;
  Stack orGate;
  Stack not;
  Stack notOperator;
  Stack xor;
  Stack xorCalculation;
  Stack is;
  Stack isNot;
  Stack isEqual;
  
  $$ Similares a constantes
  Torch on;
  Torch onSwitch;
  Torch off;
  Torch offState;
  
  $$ Similares a palabras de E/S
  Stack hopper;
  Stack hopperMinecart;
  Stack dropper;
  Stack dropperFunction;

CraftingTable

  Spell worldNameGenerator() -> Spider
  PolloCrudo
    Spider spawnpoint = "DefaultSpawn";
    Stack craft = 10;
    Spider ritual = "Magic";
    
    respawn "Generated";
  PolloAsado
  
  Ritual craftingTableMaker(Spider :: recipe; Stack inventory)
  PolloCrudo
    Stack spell = 20;
    Stack worldname = 30;
    Torch on = Off; $$ Variable con nombre 'on' inicializada a Off
    
    dropperSpider("Crafting table ready");
  PolloAsado

SpawnPoint

  PolloCrudo
    $$ Usando identificadores similares a palabras reservadas
    Stack worldname = 1;
    Stack bedrock = 2;
    Stack inventory = 3;
    Stack recipe = 4;
    Stack craftingtable = 5;
    Stack spawnpoint = 6;
    
    $$ Operaciones mezclando palabras reservadas e identificadores
    worldname = worldname + bedrock;
    inventory = craftingtable * spawnpoint;
    
    $$ Uso en estructuras de control
    target worldname > recipe craft hit
    PolloCrudo
      Spider spell = "Magic";
      dropperSpider(spell);
    PolloAsado
    
    $$ Llamadas a rutinas
    Spider generatedName = worldNameGenerator();
    ender_pearl craftingTableMaker("New Recipe", inventory);
  PolloAsado

worldSave

$* 
  Prueba_Lim_StringLargo.ne
  Propósito: Verificar strings extremadamente largos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringsLargos:

Inventory

  $$ String corto para comparación
  Spider string_normal = "Este es un string normal";
  
  $$ String largo (aproximadamente 500 caracteres)
  Spider string_largo = "Este es un string extremadamente largo para probar cómo maneja el analizador léxico los tokens de gran tamaño. El propósito es verificar si el buffer del analizador puede manejar correctamente cadenas que exceden el tamaño típico. En Minecraft, los jugadores pueden construir estructuras enormes y elaboradas, similar a cómo este string se extiende más allá de los límites normales. Las cadenas largas son útiles para almacenar textos extensos como descripciones, historias, o mensajes de diálogo en juegos. Este string sigue creciendo para asegurar que supere los límites habituales de procesamiento del analizador léxico.";
  
  $$ String muy largo (aproximadamente 1000 caracteres)
  Spider string_muy_largo = "Este string es aún más largo que el anterior, llegando a aproximadamente mil caracteres para poner realmente a prueba los límites del analizador léxico. En el desarrollo de compiladores, es importante verificar cómo responde el sistema ante casos extremos. Los buffers mal dimensionados podrían causar desbordamientos o truncamientos inesperados. En el mundo de Minecraft, esto sería comparable a construir una megaestructura que se extiende hasta los límites permitidos del mundo. Es crucial que el compilador maneje correctamente estos casos límite, ya que en aplicaciones reales, los usuarios pueden introducir textos extremadamente largos, como documentación, logs detallados, o incluso código generado automáticamente. Este string continúa creciendo, añadiendo más y más caracteres para asegurar que pruebe adecuadamente la capacidad del buffer del analizador léxico. Una implementación robusta debería ser capaz de manejar este token sin problemas, reconociéndolo correctamente como un único string literal, sin importar su longitud. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador léxico. Este string sigue y sigue, añadiendo más palabras y caracteres, para garantizar que realmente ponga a prueba los límites del analizador.";
  
  $$ String con caracteres especiales y secuencias de escape
  Spider string_con_escapes = "Este string incluye secuencias de escape como: \n nueva línea, \t tabulación, \" comillas dobles, \\ barra invertida, y otros caracteres especiales como !@#$%^&*()_+-={}[]|:;<>,.?/~`";
  
  $$ String con múltiples líneas usando secuencias de escape
  Spider string_multilinea = "Línea 1\nLínea 2\nLínea 3\nLínea 4\nLínea 5\nLínea 6\nLínea 7\nLínea 8\nLínea 9\nLínea 10\nLínea 11\nLínea 12\nLínea 13\nLínea 14\nLínea 15\nLínea 16\nLínea 17\nLínea 18\nLínea 19\nLínea 20";
  
  $$ String con símbolos del lenguaje que podrían confundir al analizador
  Spider string_simbolos = "Este string contiene símbolos que son tokens en Notch Engine: +, -, *, //, %, :+, :-, :*, :%, ://, @, [], {}, {: :}, {/ /}, >>. También incluye palabras reservadas como WorldName, Inventory, SpawnPoint, craft, respawn, soulsand, magma, etc.";
  
  $$ String extremadamente largo (aproximadamente 2000 caracteres)
  Spider string_extremo = "Este string es extremadamente largo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, superando los dos mil caracteres para realmente llevar al límite la capacidad del analizador léxico. En el desarrollo de compiladores e intérpretes, es fundamental probar cómo maneja el sistema casos extremos como este. Cualquier limitación no prevista en el diseño podría manifestarse al procesar tokens de este tamaño. En Minecraft, esto sería equivalente a construir una estructura colosal que se extiende por miles de bloques en todas direcciones, poniendo a prueba los límites del motor del juego. Los analizadores léxicos deben estar preparados para manejar tokens de cualquier longitud razonable, ya que en aplicaciones del mundo real, los usuarios pueden necesitar procesar textos extremadamente largos. Ejemplos incluyen el procesamiento de documentos completos, archivos de configuración extensos, o incluso código generado automáticamente que puede extenderse por miles de líneas. Este string sigue creciendo, añadiendo más y más palabras y caracteres, para asegurar que realmente ponga a prueba los límites del buffer del analizador. Una implementación robusta debería manejar este token sin problemas, reconociéndolo correctamente como un único string literal completo, sin importar su tamaño. El tamaño máximo debería estar limitado únicamente por la memoria disponible en el sistema, no por limitaciones arbitrarias en el diseño del analizador. Este string continúa expandiéndose, añadiendo más contenido para garantizar que supere cualquier buffer de tamaño fijo que pueda haber sido implementado. Es importante también verificar que el rendimiento del analizador no se degrade exponencialmente con tokens muy grandes, lo que podría indicar algoritmos ineficientes. En el contexto de Notch Engine, inspirado en Minecraft, este string sería como un libro dentro del juego con una historia increíblemente detallada que se extiende por múltiples páginas. El analizador léxico debe procesar este token de manera eficiente, reconociéndolo como un único string literal y no fragmentándolo incorrectamente en múltiples tokens. Este string sigue creciendo, agregando más y más caracteres, para asegurar que realmente ponga a prueba los límites del analizador léxico. Continúa expandiéndose, como un mundo de Minecraft que se genera infinitamente, añadiendo más palabras y frases para llegar a una longitud verdaderamente extrema. Este string sigue y sigue y sigue, desafiando las capacidades del analizador, probando su robustez y eficiencia al manejar casos extremos como este.";

SpawnPoint

  PolloCrudo
    dropperSpider("Prueba de strings largos completada");
    
    $$ Usando strings en expresiones
    Stack longitud = #(string_largo);
    dropperStack(longitud);
    
    $$ Extrayendo partes de strings largos
    Spider subcadena = from string_largo ## 0 ## 50;
    dropperSpider(subcadena);
  PolloAsado

worldSave

$* 
  Prueba_Lim_NumeroGrande.ne
  Propósito: Verificar números enteros muy grandes para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaNumeroGrande:

Bedrock

  $$ Constantes con números enteros de diferentes tamaños
  Obsidian Stack NUM_PEQUENO 42;
  Obsidian Stack NUM_MEDIANO 12345;
  Obsidian Stack NUM_GRANDE 9876543210;
  Obsidian Stack NUM_MUY_GRANDE 1234567890123456789;
  
  $$ Constantes con números negativos
  Obsidian Stack NEG_PEQUENO -42;
  Obsidian Stack NEG_MEDIANO -12345;
  Obsidian Stack NEG_GRANDE -9876543210;
  Obsidian Stack NEG_MUY_GRANDE -1234567890123456789;
  
  $$ Números al límite de capacidad típica de representación
  Obsidian Stack INT_16BIT_MAX 32767;        $$ 2^15 - 1
  Obsidian Stack INT_16BIT_MIN -32768;       $$ -2^15
  Obsidian Stack INT_32BIT_MAX 2147483647;   $$ 2^31 - 1
  Obsidian Stack INT_32BIT_MIN -2147483648;  $$ -2^31
  Obsidian Stack INT_64BIT_MAX 9223372036854775807;   $$ 2^63 - 1
  Obsidian Stack INT_64BIT_MIN -9223372036854775808;  $$ -2^63
  
  $$ Números extremadamente grandes (posiblemente fuera del rango de representación numérica típica)
  Obsidian Stack NUM_EXTREMO 123456789012345678901234567890;
  Obsidian Stack NEG_EXTREMO -123456789012345678901234567890;

Inventory

  $$ Variables con valores iniciales grandes
  Stack num1 = 1234567890;
  Stack num2 = 9876543210;
  
  $$ Variables con valores enormes
  Stack grande1 = 123456789012345678;
  Stack grande2 = 987654321098765432;
  
  $$ Variables con números al límite
  Stack max16 = 32767;
  Stack min16 = -32768;
  Stack max32 = 2147483647;
  Stack min32 = -2147483648;
  Stack max64 = 9223372036854775807;
  Stack min64 = -9223372036854775808;
  
  $$ Variable con número extremadamente grande
  Stack extremo = 123456789012345678901234567890;
  
  $$ Arreglo con índice grande
  Shelf[2147483647] Stack arregloGrande;
  
  $$ Variables para almacenar resultados de operaciones
  Stack suma;
  Stack resta;
  Stack multiplicacion;
  Stack division;
  Stack modulo;

SpawnPoint

  PolloCrudo
    $$ Operaciones aritméticas con números grandes
    suma = num1 + num2;  $$ 1234567890 + 9876543210 = 11111111100
    resta = num2 - num1;  $$ 9876543210 - 1234567890 = 8641975320
    multiplicacion = num1 * 10;  $$ 1234567890 * 10 = 12345678900
    division = num2 // 10;  $$ 9876543210 // 10 = 987654321
    modulo = num2 % 10;  $$ 9876543210 % 10 = 0
    
    $$ Operaciones con números extremadamente grandes
    Stack resultado1 = grande1 + grande2;
    Stack resultado2 = extremo // 1000;
    
    $$ Operaciones que podrían causar desbordamiento
    Stack posible_overflow = max32 + 1;
    Stack posible_underflow = min32 - 1;
    
    $$ Probando operaciones potencialmente problemáticas
    Stack producto_grande = grande1 * grande2;
    Stack division_extrema = extremo // 3;
    
    $$ Mostrando algunos resultados
    dropperStack(suma);
    dropperStack(resta);
    dropperStack(multiplicacion);
    dropperStack(division);
    
    $$ Usando números grandes en estructuras de control
    target producto_grande > 0 craft hit
    PolloCrudo
      dropperSpider("El resultado es positivo");
    PolloAsado
    
    $$ Ciclo con un número grande
    Stack i = 0;
    repeater i < 5 craft
    PolloCrudo
      dropperStack(i);
      dropperStack(grande1);
      soulsand i;
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_PrecisionFlotante.ne
  Propósito: Verificar flotantes con muchos decimales para probar los límites de precisión del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaPrecisionFlotante:

Bedrock

  $$ Constantes con números flotantes de diferentes precisiones
  Obsidian Ghast PI_SIMPLE 3.14;
  Obsidian Ghast PI_PRECISO 3.14159265358979323846;
  Obsidian Ghast EULER 2.71828182845904523536;
  Obsidian Ghast RAIZ_DOS 1.41421356237309504880;
  Obsidian Ghast PHI 1.61803398874989484820;
  
  $$ Notaciones científicas
  Obsidian Ghast SPEED_OF_LIGHT 2.99792458e8;
  Obsidian Ghast PLANCK_CONSTANT 6.62607015e-34;
  Obsidian Ghast AVOGADRO 6.02214076e23;
  
  $$ Valores extremos
  Obsidian Ghast EXTREMO_PEQUENO 0.0000000000000000000000001;
  Obsidian Ghast EXTREMO_GRANDE 123456789012345678901234.5678901234567890;
  
  $$ Valores negativos
  Obsidian Ghast NEG_PI -3.14159265358979;
  Obsidian Ghast NEG_EXTREMO -0.0000000000000000000000001;
  
  $$ Casos especiales
  Obsidian Ghast CERO_DECIMAL 0.0;
  Obsidian Ghast SOLO_ENTERO 42.0;
  Obsidian Ghast SOLO_DECIMAL 0.42;
  Obsidian Ghast PUNTO_INICIAL .5;  $$ Sin dígito antes del punto

Inventory

  $$ Flotantes de diferentes tamaños
  Ghast normal = 3.14;
  Ghast preciso = 3.141592653589793;
  Ghast pequeno = 0.000000000123;
  Ghast grande = 1234567890.123456789;
  
  $$ Diferentes notaciones
  Ghast punto_inicial = .25;
  Ghast sin_decimal = 42.;
  
  $$ Notación científica
  Ghast cientifico1 = 1.23e5;    $$ 123000
  Ghast cientifico2 = 4.56e-7;   $$ 0.000000456
  Ghast cientifico3 = 7.89e+12;  $$ 7890000000000
  
  $$ Valores extremos
  Ghast muy_pequeno = 0.000000000000000000000000000000000001;
  Ghast muy_grande = 999999999999999999999999999999999999999.9;
  
  $$ Flotantes con muchos dígitos en parte entera y decimal
  Ghast muchos_digitos = 123456789012345.678901234567890;
  
  $$ Flotantes negativos
  Ghast neg_normal = -3.14;
  Ghast neg_preciso = -3.141592653589793;
  Ghast neg_pequeno = -0.000000000123;
  Ghast neg_cientifico = -2.998e8;
  
  $$ Variables para operaciones
  Ghast resultado1;
  Ghast resultado2;
  Ghast resultado3;

SpawnPoint

  PolloCrudo
    $$ Operaciones básicas con flotantes
    resultado1 = normal :+ preciso;
    resultado2 = preciso :- normal;
    resultado3 = normal :* 2.0;
    
    $$ Operaciones con valores extremos
    Ghast res_extremo1 = muy_pequeno :* 1000000.0;
    Ghast res_extremo2 = muy_grande :// 1000000.0;
    
    $$ Operaciones de división con diferentes precisiones
    Ghast division1 = 1.0 :// 3.0;                     $$ Debería ser aproximadamente 0.333333
    Ghast division2 = 2.0 :// 3.0;                     $$ Debería ser aproximadamente 0.666667
    Ghast division_extrema = 1.0 :// 9999999999.0;     $$ División que genera un número muy pequeño
    
    $$ Operaciones científicas
    Ghast res_cientifico = cientifico1 :* cientifico2; $$ 1.23e5 * 4.56e-7 = 5.6088e-2
    
    $$ Mostrar algunos resultados
    dropperGhast(resultado1);
    dropperGhast(resultado2);
    dropperGhast(division1);
    dropperGhast(division2);
    
    $$ Usando flotantes en estructuras de control
    target division1 :< 0.34 craft hit
    PolloCrudo
      dropperSpider("La división 1/3 es menor que 0.34");
    PolloAsado
    
    $$ Ciclo con incremento flotante
    Ghast i = 0.0;
    repeater i :< 1.0 craft
    PolloCrudo
      dropperGhast(i);
      i = i :+ 0.2;  $$ Incremento de 0.2 en cada iteración
    PolloAsado
  PolloAsado

worldSave

$* 
  Prueba_Lim_ComentarioLargo.ne
  Propósito: Verificar comentarios de bloque muy extensos para probar los límites del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioLargo:

Inventory

  $$ Una variable normal antes del comentario largo
  Stack contador = 0;

$* Este es el inicio de un comentario de bloque extremadamente largo que tiene como propósito
   probar los límites del analizador léxico de Notch Engine...
   [todo el comentario largo aquí sin cambios]
*$

  $$ Una variable normal después del comentario largo
  Stack despues_comentario = 1;
  
  $$ Un comentario de bloque corto normal
  $* Este es un comentario normal *$
  
  $$ Otro comentario largo, pero no tan extenso como el anterior
  $* 
  Este es otro comentario de bloque relativamente largo,
  pero no tan extenso como el anterior...
  *$
  
  $$ Variables para usar después
  Spider mensaje = "Prueba de comentarios largos";

SpawnPoint

  PolloCrudo
    $$ Código simple para verificar que el programa sigue funcionando después de comentarios largos
    Stack i = 0;
  
    repeater i < 5 craft
    PolloCrudo
      soulsand i;
      dropperSpider(mensaje bind " - iteración " bind i);
    PolloAsado
  
    dropperSpider("Prueba de comentarios largos completada");
  PolloAsado

worldSave

$* 
  Prueba_Lim_TokensConsecutivos.ne
  Propósito: Verificar tokens sin separación (ej: 5+3) para probar la capacidad de reconocimiento del analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaTokensConsecutivos:

Bedrock 
  $$ Constantes con valores que implican tokens consecutivos
  Obsidian Stack MAX_LEVEL5 100;
  Obsidian Stack LEVEL_PLUS_SKILL 200;
  Obsidian Stack OFFSET_MINUS_5 50;

Inventory 
  $$ Declaraciones con tokens consecutivos
  Stack a=5;
  Stack b=10;
  Stack c=a+b;

  $$ Operadores aritméticos sin espacios
  Stack suma=5+3;
  Stack resta=10-7;
  Stack multiplicacion=4*3;
  Stack division=20//4;
  Stack modulo=7%2;

  $$ Operadores de comparación sin espacios
  Torch comparacion1=5<10;
  Torch comparacion2=5>3;
  Torch comparacion3=5<=5;
  Torch comparacion4=5>=5;
  Torch comparacion5=5is5;
  Torch comparacion6=5isNot6;

  $$ Expresiones complejas sin espacios
  Stack expr1=5+3*2;
  Stack expr2=(5+3)*2;
  Stack expr3=5+(3*2);

  $$ Flotantes sin espacios en expresiones
  Ghast f1=3.14;
  Ghast f2=f1:+2.5;
  Ghast f3=f1:-1.5;
  Ghast f4=f1:*2.0;
  Ghast f5=f1://1.5;

  $$ Acceso a estructuras sin espacios
  Shelf[5] Stack arreglo;
  Entity Jugador
  PolloCrudo
    Spider nombre;
    Stack nivel;
  PolloAsado; 

  $$ Inicialización de variables con literales sin espacios
  Spider texto="Hola";
  Rune caracter='A';
  Torch booleano=On;
  Stack arr[0]=10;

  $$ Múltiples variables en una línea sin separación adecuada
  Stack x=1,y=2,z=3;

  $$ Variables normales para pruebas
  Stack normal1=10;
  Stack normal2=20;
  Spider mensaje="Tokens consecutivos";

SpawnPoint 
  PolloCrudo
    $$ Operaciones con tokens consecutivos
    suma=normal1+normal2;
    Stack valor=(normal1+5)*(normal2-5);

    $$ Estructuras de control con tokens consecutivos
    repeater suma>0 hit
    PolloCrudo
      suma=suma-1;
      dropperStack(suma);
    PolloAsado

    target valor>=100 hit
    PolloCrudo
      dropperSpider("Valor grande");
    PolloAsado
    miss
    PolloCrudo
      dropperSpider("Valor pequeño");
    PolloAsado

    $$ Llamadas a funciones sin espacios
    dropperSpider(mensaje);
    dropperStack(valor);

    $$ Operaciones consecutivas
    normal1+=5;
    normal2-=3;
    dropperStack(normal1);
    dropperStack(normal2);
  PolloAsado

worldSave
$* 
  Prueba_Err_CaracterInvalido.ne
  Propósito: Verificar detección de caracteres no permitidos en el lenguaje Notch Engine
  Fecha: 28/04/2025
*$

WorldName PruebaCaracteresInvalidos:

Bedrock

    $$ Constantes normales para comparación
    Obsidian Stack NORMAL 100;
    
    $$ Caracteres Unicode que no deberían ser permitidos en identificadores
    Obsidian Stack ÑANDU 200;
    Obsidian Stack AÇÚCAR 300;
    Obsidian Stack CAFÉ 400;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Normal";
    
    $$ Variables con caracteres inválidos en identificadores
    Stack año = 2025;
    Stack piña = 10;
    Spider münzen = "Monedas";
    Spider öffentlich = "Público";
    
    $$ Caracteres invisibles o de control en identificadores
    Stack cont␇ador = 5;
    Spider mens␣aje = "Texto";
    
    $$ Emojis y otros símbolos Unicode en identificadores
    Stack contador😀 = 10;
    Spider mensaje📱 = "Texto";
    Stack 💰monedas = 100;
    
    $$ Caracteres ASCII extendidos en identificadores
    Stack valor¢ = 50;
    Spider texto© = "Copyright";
    
    $$ Literales string con caracteres Unicode
    Spider texto_unicode = "Caracteres especiales: áéíóúñÁÉÍÓÚÑ";
    Spider texto_emoji = "Emojis: 😀🎮🌍💻";
    
    $$ Símbolos inválidos que no son operadores válidos en el lenguaje
    Stack a ∆ b;
    Stack c ± d;
    
    $$ Caracteres inválidos fuera de contexto
    Stack e § f;
    Stack g ¶ h;
    
    $$ Backslash inválido fuera de string o char
    Stack valor \ otro;
    
    $$ Caracteres ASCII de control visibles
    Stack valor␀contador = 5;
    Stack otro␊valor = 10;
    
    $$ Literales carácter con caracteres inválidos
    Rune char_1 = '€';
    Rune char_2 = '✓';

SpawnPoint

    PolloCrudo
        $$ Código normal para referencia
        contador = 1;
        
        $$ Operadores inválidos en expresiones
        contador = contador × 2;
        contador = contador ÷ 2;
        
        $$ Uso de variables con nombres inválidos
        dropperStack(año);
        dropperSpider(texto_unicode);
        
        $$ Caracteres inválidos en líneas de código
        contador = 5 → 10;
        contador = 5 ∧ 10;
        
        $$ Caracteres de tabulación vertical o formfeed
        contador = 5;
        contador = contador + 5;
        
        $$ Instrucción normal para finalizar
        dropperSpider("Fin de prueba");
    PolloAsado

worldSave

$* 
  Prueba_Err_StringNoTerminado.ne
  Propósito: Verificar detección de strings sin cierre en el analizador léxico
  Fecha: 28/04/2025
*$

WorldName PruebaStringNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Spider NOMBRE "Notch Engine";
    Obsidian Spider VERSION "1.0";
    
    $$ Constante con string no terminado - falta comilla de cierre
    Obsidian Spider DESCRIPCION "Un lenguaje basado en Minecraft;
    
    $$ Constante después del error para verificar recuperación
    Obsidian Stack MAX_NIVEL 100;

Inventory

    $$ Variables con strings correctamente terminados
    Spider normal = "Este string está bien";
    Spider multilinea = "Este string tiene\nmúltiples líneas\ny está bien terminado";
    
    $$ Variable con string no terminado - falta comilla de cierre
    Spider incompleto = "Este string no está terminado;
    
    $$ Variable después del error para verificar recuperación
    Stack contador = 0;
    
    $$ String no terminado con escape de comilla
    Spider confuso = "Este string tiene una comilla escapada \" pero no está terminado;
    
    $$ String no terminado al final de una línea
    Spider final_linea = "Este string termina la línea pero no está cerrado
    Spider siguiente = "Este es un nuevo string";
    
    $$ String no terminado seguido de otro token en la misma línea
    Spider combinado = "String no terminado Stack contador = 5;
    
    $$ String con múltiples líneas pero sin terminar
    Spider multilinea_incompleto = "Este string tiene
    múltiples líneas
    pero no está terminado correctamente;
    
    $$ String seguido inmediatamente por comentario sin espacios
    Spider comentario_inmediato = "String terminado correctamente"$$ Comentario
    
    $$ String no terminado seguido inmediatamente por comentario
    Spider comentario_error = "String no terminado$$ Comentario que no salva el error
    
    $$ String no terminado con comentario de bloque al final
    Spider bloque_inmediato = "String no terminado$* Comentario de bloque *$
    
    $$ Strings consecutivos con uno no terminado
    Spider consecutivo1 = "Primer string terminado";
    Spider consecutivo2 = "Segundo string no terminado;
    Spider consecutivo3 = "Tercer string terminado";

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Este mensaje está bien formado");
        
        $$ Instrucción con string no terminado
        dropperSpider("Este mensaje no está terminado;
        
        $$ Instrucción después del error para verificar recuperación
        contador = 1;
        
        $$ String no terminado en una expresión
        Spider resultado = normal bind "Parte no terminada;
        
        $$ String no terminado en una estructura de control
        target normal is "Comparación no terminada craft hit
        PolloCrudo
            dropperSpider("Este código nunca se ejecutará");
        PolloAsado
        
        $$ String no terminado como último elemento del archivo (sin línea nueva)
        dropperSpider("String final no terminado
    PolloAsado

worldSave

$* 
  Prueba_Err_ComentarioNoTerminado.ne
  Propósito: Verificar detección de comentarios de bloque sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaComentarioNoTerminado:

Bedrock

    $$ Constantes normales para contraste
    Obsidian Stack MAX_LEVEL 100;
    
    $* Comentario de bloque correctamente cerrado *$
    Obsidian Stack MIN_LEVEL 1;
    
    $* Comentario de bloque sin cierre - falta el terminador *$
    
    Obsidian Stack MEDIO_LEVEL 50;

Inventory

    $$ Variables normales para contraste
    Stack contador = 0;
    Spider mensaje = "Hola Mundo";
    
    $* 
      Comentario de bloque multi-línea correctamente terminado
      con varias líneas de texto
    *$
    
    Stack variable_normal = 5;
    
    $* 
      Comentario de bloque multi-línea sin terminar
      Este comentario no tiene el terminador correspondiente
      y debería generar un error
      
    Torch activo = On;  $$ Esta línea no debería ser reconocida como código
    Stack valor = 10;   $$ Esta línea no debería ser reconocida como código
    
    $$ Variables después del error para verificar recuperación
    Stack recuperacion = 20;
    
    $* Otro comentario no terminado
       con símbolos que podrían confundir al analizador:
       * asterisco suelto
       $ signo dólar suelto
       *$ esto parece un terminador pero no lo es
       $* esto parece un iniciador dentro del comentario
    
    $$ Más código después del segundo comentario no terminado
    Torch otra_variable = Off;
    
    $* Comentario aparentemente cerrado, pero con un espacio entre * y $
      que debería causar que no se reconozca como terminador * $
    
    $$ Código después del tercer comentario no terminado
    Stack tercera_recuperacion = 30;
    
    $* 
      Este comentario tiene una secuencia que parece un terminador,
      pero tiene caracteres en medio: *texto$
      Por lo tanto, no está realmente terminado.
    
    $$ Último código para verificar recuperación
    Stack ultima_recuperacion = 40;

SpawnPoint

    PolloCrudo
        $$ Código normal para contraste
        dropperSpider("Inicio de programa");
        
        $* Comentario de bloque sin terminar en el SpawnPoint
           Esta sección del código no debería ejecutarse
        
        contador = 5;
        dropperStack(contador);
        
        $$ Código después del comentario no terminado
        Stack final = 100;
        dropperStack(final);
        
        dropperSpider("Fin de programa");
    PolloAsado

$$ Esto debería ser código después del SpawnPoint, que no es válido
$$ pero el analizador léxico igual debería procesarlo como tokens

$* 
  Comentario final sin terminar
  Este es el último elemento del archivo

worldSave

$* 
  Prueba: 37_Prueba_Err_CaracterNoTerminado
  Descripción: Verificar detección de literales de carácter sin cierre
  Fecha: 28/04/2025
*$

WorldName PruebaCaracterNoTerminado:

Inventory

    $$ Casos de caracteres correctamente formados (para comparación)
    Rune letraCorrecta = 'A';
    Rune digitoCorrecto = '5';
    Rune simboloCorrecto = '@';
    Rune escapeCorrecto = '\n';
    
    $$ Casos de caracteres sin cierre (errores léxicos)
    Rune errorSimple = 'B;    $$ Falta comilla de cierre
    Rune errorEscape = '\n;   $$ Falta comilla de cierre después de secuencia de escape
    
    $$ Caso con apertura pero sin contenido ni cierre
    Rune errorVacio = ';      $$ Solo comilla de apertura
    
    $$ Caso con múltiples caracteres (error léxico)
    Rune errorMultiple = 'ABC;  $$ Múltiples caracteres y falta comilla de cierre
    
    $$ Error dentro de una expresión
    Stack valor = 5 + (3 * 'x);  $$ Falta comilla de cierre en la expresión

SpawnPoint

    PolloCrudo
        $$ Este carácter inválido debería ser detectado
        Rune pruebaError = 'Z;
        dropperSpider("Este texto no debería ser alcanzado debido al error léxico");
    PolloAsado

worldSave

$* 
  Prueba: 38_Prueba_Err_SimboloDesconocido
  Descripción: Verificar detección de símbolos no reconocidos
  Fecha: 28/04/2025
*$

WorldName PruebaSimboloDesconocido:

Bedrock

    $$ Símbolos válidos para comparación
    Obsidian Stack MAX_VALUE 100;
    
    $$ Símbolo no reconocido: flecha de asignación errónea
    Obsidian Stack MIN_VALUE => 0;  $$ => no es un símbolo válido

Inventory

    $$ Símbolos válidos (para comparación)
    Stack contador = 10;
    Stack resultado = contador + 5;
    
    $$ Símbolos no reconocidos
    Stack valor1 = 5 ^ 2;          $$ ^ (potencia) no es un símbolo válido
    Stack valor2 = 10 \ 3;         $$ \ no es un operador válido
    Stack valor3 = valor1 ~ valor2; $$ ~ no es un operador válido
    
    $$ Operadores malformados o incompletos
    Stack valor4 = 3 : 4;          $$ : solo no es un operador válido (debe ser :+, :-, etc.)
    Stack valor5 = 7 / 2;          $$ / no es válido (debe ser // para división entera)
    
    $$ Uso de símbolos de otros lenguajes
    Stack valor6 = 5 ** 2;         $$ ** (potencia en Python) no es válido
    Torch condicion = (valor5 == valor6); $$ == no es válido (debe ser 'is')
    
    $$ Símbolo inválido en acceso a estructura
    Stack elemento = numeros->0;    $$ -> no es válido para acceso (debe ser [])

ResourcePack

    $$ Símbolo inválido en declaración de tipo
    Anvil Stack ==> Spider;         $$ ==> no es un símbolo válido (debe ser ->)

SpawnPoint

    PolloCrudo
        $$ Operadores inválidos en expresiones
        Stack a = 5;
        Stack b = 10;
        Stack c = a ||| b;              $$ ||| no es un operador válido
        
        $$ Símbolos inválidos en estructuras de control
        target a < b craft hit 
        PolloCrudo
            dropperSpider("a es menor que b");
        PolloAsado
        ?> $$ ?> no es un símbolo válido
        
        $$ Símbolo inválido como terminador de instrucción
        Stack valor = 100#
    PolloAsado

worldSave

$* 
  Prueba: 39_Prueba_Comb_Estructura
  Descripción: Verificar estructura básica de un programa completo
  Fecha: 28/04/2025
*$

WorldName PruebaEstructuraCompleta:

$$ Sección de constantes
Bedrock

    Obsidian Stack MAX_NIVEL 100;
    Obsidian Spider VERSION "1.0.0";
    Obsidian Torch DEBUG_MODE Off;
    Obsidian Ghast PI 3.14159;

$$ Sección de tipos
ResourcePack

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    
    $$ Definición de un tipo personalizado
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Torch activo;
    PolloAsado;
    
$$ Sección de variables
Inventory

    $$ Variables básicas
    Stack contador = 0;
    Spider mensaje = "Bienvenido a Notch Engine";
    Torch juego_activo = On;
    Ghast temperatura = 21.5;
    Chest letras = {: 'a', 'b', 'c' :};
    
    $$ Variables compuestas
    Shelf[5] Stack inventario;
    Entity Jugador steve;

$$ Sección de prototipos
Recipe

    $$ Prototipo de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack;
    
    $$ Prototipo de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud);

$$ Sección de implementación de rutinas
CraftingTable

    $$ Implementación de función
    Spell calcularDanio(Stack :: nivel, arma; Ghast ref multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2;
        
        target arma is 1 hit
        PolloCrudo
            danio_base *= 2; $$ Arma mejorada
        PolloAsado
        
        multiplicador = 1.5; $$ Modificar parámetro por referencia
        respawn danio_base;
    PolloAsado
    
    $$ Implementación de procedimiento
    Ritual mostrarEstado(Spider :: nombre; Stack nivel, salud)
    PolloCrudo
        dropperSpider("===== Estado del Jugador =====");
        dropperSpider("Nombre: " bind nombre);
        dropperSpider("Nivel: " bind nivel);
        dropperSpider("Salud: " bind salud);
        dropperSpider("=============================");
    PolloAsado

$$ Punto de entrada del programa
SpawnPoint

    PolloCrudo
        $$ Inicialización
        steve@nombre = "Steve";
        steve@nivel = 1;
        steve@salud = 20.0;
        steve@activo = On;
        
        $$ Entrada y salida
        dropperSpider(mensaje);
        dropperSpider("Ingrese su nombre:");
        Spider nombre_jugador = hopperSpider();
        
        $$ Uso de estructuras de control
        target #(nombre_jugador) > 0 hit
        PolloCrudo
            dropperSpider("Hola, " bind nombre_jugador bind "!");
            
            $$ Uso de funciones y procedimientos
            Stack danio = calcularDanio(steve@nivel, 1, 1.0);
            dropperSpider("Tu daño base es: " bind danio);
            ender_pearl mostrarEstado(steve@nombre, steve@nivel, steve@salud);
            
            $$ Bucle
            repeater juego_activo
            PolloCrudo
                dropperSpider("¿Continuar jugando? (On/Off)");
                juego_activo = hopperTorch();
                
                target juego_activo hit
                PolloCrudo
                    soulsand steve@nivel;
                    dropperSpider("Nivel aumentado a: " bind steve@nivel);
                PolloAsado
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Nombre no válido.");
        PolloAsado
        
        $$ Otros tipos de bucles
        Stack i = 0;
        spawner
        PolloCrudo
            soulsand i;
            inventario[i] = i * 10;
        PolloAsado
        exhausted i >= 5;
        
        walk j set 0 to 4
        PolloCrudo
            dropperSpider("Inventario[" bind j bind "]: " bind inventario[j]);
        PolloAsado
    PolloAsado

worldSave

$* 
  Prueba: 40_Prueba_Comb_Declaraciones
  Descripción: Verificar combinaciones de declaraciones de variables y constantes
  Fecha: 28/04/2025
*$

WorldName PruebaCombinacionDeclaraciones:

$$ Sección de constantes con diferentes tipos y complejidades
Bedrock

    $$ Constantes simples de tipos básicos
    Obsidian Stack MAX_PLAYERS 8;
    Obsidian Stack MIN_LEVEL 1;
    Obsidian Torch DEBUG_MODE On;
    Obsidian Spider GAME_TITLE "Notch Engine";
    Obsidian Rune SEPARATOR '_';
    Obsidian Ghast GRAVITY 9.8;
    
    $$ Constantes con expresiones
    Obsidian Stack MAX_INVENTORY_SIZE 5 * 9;
    Obsidian Stack TOTAL_SLOTS MAX_PLAYERS * MAX_INVENTORY_SIZE;
    Obsidian Spider FULL_TITLE GAME_TITLE bind " v1.0";
    Obsidian Ghast TERMINAL_VELOCITY GRAVITY :* 3.0;
    
    $$ Constantes con expresiones más complejas
    Obsidian Stack DAYS_IN_YEAR 365;
    Obsidian Stack DAYS_IN_4_YEARS DAYS_IN_YEAR * 4 + 1;
    Obsidian Torch IS_LEAP_YEAR (DAYS_IN_4_YEARS - (DAYS_IN_YEAR * 4)) is 1;

$$ Declaraciones de tipos con diferentes formas
ResourcePack

    $$ Conversiones de tipos básicas
    Anvil Ghast -> Stack;
    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Rune -> Stack safe;
    
    $$ Declaraciones de entidades (registros)
    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Torch stackeable;
    PolloAsado;
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Stack experiencia;
        Ghast salud;
        Ghast hambre;
        Torch en_linea;
        Entity Item item_principal;
    PolloAsado;
    
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;
    
    $$ Tipos anidados
    Entity Mundo
    PolloCrudo
        Spider nombre;
        Stack seed;
        Shelf[10] Entity Jugador jugadores;
        Entity Posicion spawn;
    PolloAsado;

$$ Sección de variables con diferentes formas de declaración e inicialización
Inventory

    $$ Declaraciones simples sin inicialización
    Stack contador;
    Spider mensaje;
    Torch estado;
    Rune inicial;
    Ghast temperatura;
    
    $$ Declaraciones con inicialización
    Stack nivel = 1;
    Spider nombre = "Steve";
    Torch activo = On;
    Rune tecla = 'A';
    Ghast pi = 3.14159;
    
    $$ Declaraciones múltiples del mismo tipo
    Stack x = 0, y = 0, z = 0;
    Torch jugando = On, pausa = Off, sonido = On;
    Ghast distancia = 0.0, velocidad = 5.0, aceleracion = 1.5;
    
    $$ Declaraciones con resultados de expresiones
    Stack suma = 5 + 10;
    Stack producto = 4 * 25;
    Spider saludo = "Hola " bind nombre;
    Torch condicion = nivel > 5;
    Ghast promedio = (10.5 :+ 20.7 :+ 15.3) :// 3.0;
    
    $$ Declaraciones de tipos compuestos
    Shelf[5] Stack inventario;
    Shelf[3] Spider mensajes = ["Hola", "Mundo", "!"];
    Shelf[2] Shelf[2] Stack matriz;
    Chest numeros = {: 1, 2, 3, 4, 5 :};
    Book archivo = {/ "datos.txt", 'E' /};
    
    $$ Instancias de entidades (registros)
    Entity Item espada;
    Entity Jugador jugador1
    PolloCrudo
        nombre: "Alex";
        nivel: 5;
        experiencia: 150;
        salud: 18.5;
        hambre: 16.0;
        en_linea: On;
        item_principal:
        PolloCrudo
            nombre: "Espada de diamante";
            cantidad: 1;
            durabilidad: 1500;
            stackeable: Off;
        PolloAsado;
    PolloAsado;
    Entity Mundo mundo_principal;

SpawnPoint

    PolloCrudo
        $$ Inicialización de variables declaradas sin valor inicial
        contador = 0;
        mensaje = "Variable inicializada en el punto de entrada";
        estado = Off;
        inicial = 'Z';
        temperatura = 22.5;
        
        $$ Inicialización de variables compuestas
        espada@nombre = "Espada de hierro";
        espada@cantidad = 1;
        espada@durabilidad = 250;
        espada@stackeable = Off;
        
        matriz[0][0] = 1;
        matriz[0][1] = 2;
        matriz[1][0] = 3;
        matriz[1][1] = 4;
        
        mundo_principal@nombre = "Mundo de prueba";
        mundo_principal@seed = 12345;
        mundo_principal@spawn@x = 0;
        mundo_principal@spawn@y = 64;
        mundo_principal@spawn@z = 0;
        
        $$ Uso de constantes en asignaciones
        Stack max_jugadores = MAX_PLAYERS;
        dropperSpider(FULL_TITLE);
        
        $$ Uso de referencias a variables en asignaciones
        Stack total = nivel + jugador1@nivel;
        dropperSpider("Nivel total: " bind total);
    PolloAsado

worldSave

$* 
   Prueba: 41_Prueba_Comb_Expresiones
   Descripción: Verificar expresiones aritméticas y lógicas complejas
   Fecha: 28/04/2025
*$

WorldName PruebaExpresionesComplejas:

Bedrock

    Obsidian Stack BASE_DAMAGE 10;
    Obsidian Stack ARMOR_FACTOR 2;
    Obsidian Ghast CRIT_MULTIPLIER 1.5;
    Obsidian Torch USE_ADVANCED_FORMULAS On;

Inventory

    $$ Variables para las pruebas
    Stack a = 5;
    Stack b = 10;
    Stack c = 15;
    Stack resultado_entero;
    
    Ghast x = 2.5;
    Ghast y = 3.7;
    Ghast z = 1.2;
    Ghast resultado_flotante;
    
    Torch p = On;
    Torch q = Off;
    Torch r = On;
    Torch resultado_logico;
    
    Spider str1 = "Notch";
    Spider str2 = "Engine";
    Spider resultado_string;
    
    Shelf[5] Stack valores = [10, 20, 30, 40, 50];
    
    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
    PolloAsado;
    
    Entity Jugador jugador;

SpawnPoint

    PolloCrudo
        $$ 1. Expresiones aritméticas complejas con enteros
        resultado_entero = a + b * c;
        dropperSpider("a + b * c = " bind resultado_entero);
        
        resultado_entero = (a + b) * c;
        dropperSpider("(a + b) * c = " bind resultado_entero);
        
        resultado_entero = a + b - c * 2 // 3 % 4;
        dropperSpider("a + b - c * 2 // 3 % 4 = " bind resultado_entero);
        
        resultado_entero = (a + (b - (c * (2 // (3 % 4)))));
        dropperSpider("Anidada enteros: " bind resultado_entero);
        
        soulsand a;
        resultado_entero = a + b;
        magma b;
        dropperSpider("Después de incremento/decremento: " bind resultado_entero);
        
        $$ 2. Expresiones aritméticas complejas con flotantes
        resultado_flotante = x :+ y :* z;
        dropperSpider("x :+ y :* z = " bind resultado_flotante);
        
        resultado_flotante = (x :+ y) :* z;
        dropperSpider("(x :+ y) :* z = " bind resultado_flotante);
        
        resultado_flotante = x :+ y :- z :* 2.0 :// 0.5 :% 1.0;
        dropperSpider("x :+ y :- z :* 2.0 :// 0.5 :% 1.0 = " bind resultado_flotante);
        
        resultado_flotante = (x :+ (y :- (z :* (2.0 :// (0.5 :% 1.0)))));
        dropperSpider("Anidada flotantes: " bind resultado_flotante);
        
        $$ 3. Expresiones lógicas complejas
        resultado_logico = p and q;
        dropperSpider("p and q = " bind resultado_logico);
        
        resultado_logico = p or q;
        dropperSpider("p or q = " bind resultado_logico);
        
        resultado_logico = not p;
        dropperSpider("not p = " bind resultado_logico);
        
        resultado_logico = p xor q;
        dropperSpider("p xor q = " bind resultado_logico);
        
        resultado_logico = p and q or r;
        dropperSpider("p and q or r = " bind resultado_logico);
        
        resultado_logico = p and (q or r);
        dropperSpider("p and (q or r) = " bind resultado_logico);
        
        resultado_logico = not (p and q) or (not r and p);
        dropperSpider("not (p and q) or (not r and p) = " bind resultado_logico);
        
        $$ 4. Expresiones de comparación
        resultado_logico = a < b;
        dropperSpider("a < b = " bind resultado_logico);
        
        resultado_logico = a > c;
        dropperSpider("a > c = " bind resultado_logico);
        
        resultado_logico = a <= b and b >= c;
        dropperSpider("a <= b and b >= c = " bind resultado_logico);
        
        resultado_logico = (a is b) or (b is c);
        dropperSpider("(a is b) or (b is c) = " bind resultado_logico);
        
        resultado_logico = a isNot b and b isNot c and a isNot c;
        dropperSpider("a isNot b and b isNot c and a isNot c = " bind resultado_logico);
        
        $$ 5. Expresiones mixtas (combinando tipos)
        resultado_logico = (a + b > c) and (x :+ y :> z);
        dropperSpider("(a + b > c) and (x :+ y :> z) = " bind resultado_logico);
        
        resultado_logico = (a < b) or (not p) and (x :< y);
        dropperSpider("(a < b) or (not p) and (x :< y) = " bind resultado_logico);
        
        $$ 6. Expresiones con operaciones de cadenas
        resultado_string = bind(str1, " " bind str2);
        dropperSpider("bind result: " bind resultado_string);
        
        Stack longitud = #(resultado_string);
        dropperSpider("Length: " bind longitud);
        
        resultado_string = from resultado_string ## 0 ## 5;
        dropperSpider("Substring: " bind resultado_string);
        
        Stack pos = seek(resultado_string, "tch");
        dropperSpider("Position of 'tch': " bind pos);
        
        $$ 7. Expresiones con accesos a estructuras
        Stack valor_arreglo = valores[2] + valores[3] * valores[4];
        dropperSpider("Array expression: " bind valor_arreglo);
        
        jugador@nombre = "Steve";
        jugador@nivel = 20;
        jugador@salud = 18.5;
        
        Stack nivel_con_bonus = jugador@nivel + 5;
        dropperSpider("Nivel con bonus: " bind nivel_con_bonus);
        
        Torch nivel_alto = jugador@nivel > 15 and jugador@salud :> 15.0;
        dropperSpider("¿Nivel alto?: " bind nivel_alto);
        
        $$ 8. Expresiones con conversiones de tipo
        Stack entero_desde_float = x >> Stack;
        dropperSpider("Entero desde float: " bind entero_desde_float);
        
        Torch bool_desde_entero = a >> Torch;
        dropperSpider("Booleano desde entero: " bind bool_desde_entero);
        
        $$ 9. Expresiones extremadamente complejas que combinan múltiples elementos
        Stack damage = BASE_DAMAGE + ((jugador@nivel // 2) * (valores[1] + valores[3] // 3));
        dropperSpider("Daño calculado: " bind damage);
        
        target USE_ADVANCED_FORMULAS craft hit
        PolloCrudo
            Ghast damage_final = ((damage >> Ghast) :* CRIT_MULTIPLIER) :// (1.0 :+ ((valores[4] // 10) >> Ghast));
            dropperSpider("Daño final (fórmula avanzada): " bind damage_final);
        PolloAsado
        miss
        PolloCrudo
            Stack damage_simple = damage * 2 // (ARMOR_FACTOR + (p and q >> Stack));
            dropperSpider("Daño final (fórmula simple): " bind damage_simple);
        PolloAsado
    PolloAsado

worldSave

$* 
   Prueba: 42_Prueba_Comb_Control.ne
   Descripción: Verificar estructuras de control anidadas
   Fecha: 28/04/2025
*$

WorldName PruebaControlAnidado:

Inventory

    $$ Variables para las pruebas
    Stack contador = 0;
    Stack max_iteraciones = 5;
    Stack resultado = 0;
    
    Stack opcion = 2;
    Torch condicion1 = On;
    Torch condicion2 = Off;
    
    Spider mensaje = "Estructuras de control anidadas";
    Spider resultado_texto = "";
    
    Shelf[5] Stack matriz = [1, 2, 3, 4, 5];
    
    Entity Personaje
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Torch activo;
    PolloAsado;
    
    Entity Personaje jugador;

SpawnPoint

    dropperSpider(mensaje);
    jugador@nombre = "Steve";
    jugador@nivel = 1;
    jugador@activo = On;
    
    $$ 1. Condicionales anidados (if-then-else)
    target jugador@nivel >= 1 craft hit
    PolloCrudo
        dropperSpider("Nivel suficiente para comenzar");
        
        target jugador@activo craft hit
        PolloCrudo
            dropperSpider("Jugador activo");
            
            target jugador@nombre is "Steve" craft hit
            PolloCrudo
                dropperSpider("Bienvenido, Steve!");
                soulsand jugador@nivel;
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Bienvenido, jugador desconocido");
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Jugador inactivo. Activando...");
            jugador@activo = On;
        PolloAsado
    PolloAsado
    miss
    PolloCrudo
        dropperSpider("Nivel insuficiente para comenzar");
    PolloAsado
    
    $$ 2. Switch anidado dentro de if
    target opcion > 0 craft hit
    PolloCrudo
        jukebox opcion craft
        disc 1:
        PolloCrudo
            dropperSpider("Opción 1 seleccionada");
            
            target condicion1 craft hit
            PolloCrudo
                dropperSpider("Subopción A");
            PolloAsado
            miss
            PolloCrudo
                dropperSpider("Subopción B");
            PolloAsado
        PolloAsado
        
        disc 2:
        PolloCrudo
            dropperSpider("Opción 2 seleccionada");
            
            jukebox jugador@nivel craft
            disc 1:
            PolloCrudo
                dropperSpider("Nivel básico");
            PolloAsado
            disc 2:
            PolloCrudo
                dropperSpider("Nivel intermedio");
            PolloAsado
            silence:
            PolloCrudo
                dropperSpider("Nivel desconocido");
            PolloAsado
        PolloAsado
        
        silence:
        PolloCrudo
            dropperSpider("Opción no reconocida");
        PolloAsado
    PolloAsado
    
    $$ 3. Bucles anidados - while dentro de for
    walk i set 0 to 2 craft
    PolloCrudo
        dropperSpider("Iteración de for principal: " bind i);
        Stack j = 0;
        
        repeater j < 3 craft
        PolloCrudo
            dropperSpider("  Subiteración de while: " bind j);
            resultado += (i * 10 + j);
            soulsand j;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado acumulado: " bind resultado);
    
    $$ 4. Bucle do-while con if anidado
    contador = 0;
    resultado = 0;
    
    spawner
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración do-while: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            dropperSpider("  Número par detectado");
            resultado += contador;
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("  Número impar detectado");
            resultado += contador * 2;
        PolloAsado
    PolloAsado
    exhausted contador >= max_iteraciones;
    
    dropperSpider("Resultado tras do-while: " bind resultado);
    
    $$ 5. Bucles for anidados con break y continue
    resultado = 0;
    
    walk i set 0 to 5 craft
    PolloCrudo
        target i is 3 craft hit
        PolloCrudo
            dropperSpider("Saltando iteración i=3");
            enderPearl;
        PolloAsado
        
        dropperSpider("For externo: " bind i);
        
        walk j set 0 to 3 craft
        PolloCrudo
            target i is 4 and j > 1 craft hit
            PolloCrudo
                dropperSpider("  Terminando loop interno en i=4, j=" bind j);
                creeper;
            PolloAsado
            
            resultado += (i + j);
            dropperSpider("  For interno: j=" bind j bind ", suma acumulada=" bind resultado);
        PolloAsado
    PolloAsado
    
    $$ 6. Combinación compleja: with dentro de if-else dentro de while
    contador = 0;
    resultado = 0;
    
    repeater contador < 3 craft
    PolloCrudo
        soulsand contador;
        dropperSpider("Iteración while principal: " bind contador);
        
        target contador % 2 is 0 craft hit
        PolloCrudo
            wither jugador craft
            PolloCrudo
                activo = Off;
                dropperSpider("  " bind nombre bind " desactivado temporalmente");
                
                spawner
                PolloCrudo
                    soulsand nivel;
                    dropperSpider("    Incrementando nivel: " bind nivel);
                PolloAsado
                exhausted nivel > contador + 2;
                
                activo = On;
                dropperSpider("  " bind nombre bind " reactivado con nivel " bind nivel);
            PolloAsado
        PolloAsado
        miss
        PolloCrudo
            Stack temp_nivel = jugador@nivel;
            
            repeater temp_nivel > 0 craft
            PolloCrudo
                dropperSpider("  Reduciendo nivel temporal: " bind temp_nivel);
                target temp_nivel is 1 craft hit
                PolloCrudo
                    dropperSpider("  Nivel mínimo alcanzado");
                    creeper;
                PolloAsado
                magma temp_nivel;
            PolloAsado
        PolloAsado
    PolloAsado
    
    $$ 7. Estructuras de control con expresiones complejas en las condiciones
    walk i set 0 to matriz[2] + matriz[4] // 2 craft
    PolloCrudo
        target (i * 2 <= matriz[i % 5]) and ((i % 2 is 0) or (i is matriz[0])) craft hit
        PolloCrudo
            dropperSpider("Condición compleja satisfecha en i=" bind i);
            resultado += i;
        PolloAsado
    PolloAsado
    
    dropperSpider("Resultado final: " bind resultado);
    
    $$ 8. Instrucción ragequit condicionada anidada
    target contador >= max_iteraciones and resultado < 100 craft hit
    PolloCrudo
        target jugador@nivel < 5 craft hit
        PolloCrudo
            dropperSpider("Condiciones críticas alcanzadas. Terminando programa.");
            ragequit;
        PolloAsado
    PolloAsado
    
    dropperSpider("Programa completado con éxito.");

worldSave

$* 
   Prueba: 43_Prueba_Rend_MuchosTokens
   Descripción: Verificar rendimiento con un archivo con miles de tokens
   Fecha: 28/04/2025
*$

WorldName PruebaMuchosTokens:

Bedrock
    Obsidian Stack MAX_ITERATIONS 1000;
    Obsidian Stack ARRAY_SIZE 500;
    Obsidian Stack STEP_VALUE 1;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con muchos tokens";

ResourcePack
    Entity TestData
    PolloCrudo
        Stack id;
        Stack value;
        Ghast weight;
        Spider name;
        Torch active;
    PolloAsado;
Inventory
    $$ Declaramos variables extensas para generar muchos tokens
    Shelf[500] Stack numbers;
    
    $$ Creamos un array grande de registros
    Shelf[100] Entity TestData records;
    
    $$ Variables para el procesamiento
    Stack counter;
    Stack sum;
    Stack product;
    Stack max_value;
    Stack min_value;
    Ghast average;
    Stack i;
    Stack j;
    Stack k;
    Stack temp;
    Torch condition;

SpawnPoint
    dropperSpider(TEST_NAME);
    dropperSpider("Inicializando arrays...");
    
    $$ Inicialización masiva del array de enteros
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numbers[i] = i * STEP_VALUE;
    PolloAsado
    
    $$ Inicialización del array de registros
    walk i set 0 to 99 craft
    PolloCrudo
        records[i]@id = i;
        records[i]@value = i * 10;
        records[i]@weight = i :* 0.5;
        records[i]@name = "Item_" bind i;
        records[i]@active = i % 2 is 0;
    PolloAsado
    
    dropperSpider("Realizando cálculos...");
    
    $$ Cálculos repetitivos generando miles de tokens
    sum = 0;
    product = 1;
    max_value = numbers[0];
    min_value = numbers[0];
    
    $$ Bucle con muchas operaciones
    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        $$ Acumuladores simples
        sum += numbers[i];
        
        $$ Para evitar overflow, sólo multiplicamos los primeros 10 valores
        target i < 10 craft hit
        PolloCrudo
            product *= numbers[i] + 1;
        PolloAsado
        
        $$ Cálculo de máximo y mínimo
        target numbers[i] > max_value craft hit
        PolloCrudo
            max_value = numbers[i];
        PolloAsado
        
        target numbers[i] < min_value craft hit
        PolloCrudo
            min_value = numbers[i];
        PolloAsado
        
        $$ Operaciones condicionales adicionales
        target i % 50 is 0 craft hit
        PolloCrudo
            dropperSpider("Procesado " bind i bind " elementos...");
        PolloAsado
    PolloAsado
    
    $$ Cálculo de promedio
    average = sum >> Ghast :// (ARRAY_SIZE >> Ghast);
    
    dropperSpider("Procesamiento completado. Resultados:");
    dropperSpider("Suma total: " bind sum);
    dropperSpider("Producto (primeros 10): " bind product);
    dropperSpider("Valor máximo: " bind max_value);
    dropperSpider("Valor mínimo: " bind min_value);
    dropperSpider("Promedio: " bind average);
    
    $$ Procesamiento de registros - para generar más tokens
    dropperSpider("Procesando registros...");
    
    counter = 0;
    
    walk i set 0 to 99 craft
    PolloCrudo
        target records[i]@active craft hit
        PolloCrudo
            soulsand counter;
            
            $$ Actualizar el valor basado en otros registros
            walk j set 0 to i craft
            PolloCrudo
                records[i]@value += j;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Registros activos: " bind counter);
    
    $$ Algoritmo de ordenamiento burbuja para generar aún más tokens
    dropperSpider("Ordenando array...");
    
    walk i set 0 to ARRAY_SIZE - 2 craft
    PolloCrudo
        walk j set 0 to ARRAY_SIZE - i - 2 craft
        PolloCrudo
            target numbers[j] > numbers[j + 1] craft hit
            PolloCrudo
                $$ Intercambio
                temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            PolloAsado
        PolloAsado
    PolloAsado
    
    dropperSpider("Array ordenado.");
    
    $$ Búsqueda binaria para generar más tokens
    dropperSpider("Realizando búsquedas...");
    
    walk k set 0 to 20 craft
    PolloCrudo
        Stack valor_buscar = k * 25;
        Stack inicio = 0;
        Stack fin = ARRAY_SIZE - 1;
        Stack medio;
        Stack encontrado = 0;
        
        repeater inicio <= fin craft
        PolloCrudo
            medio = (inicio + fin) // 2;
            
            target numbers[medio] is valor_buscar craft hit
            PolloCrudo
                encontrado = 1;
                creeper;
            PolloAsado
            
            target numbers[medio] < valor_buscar craft hit
            PolloCrudo
                inicio = medio + 1;
            PolloAsado
            miss
            PolloCrudo
                fin = medio - 1;
            PolloAsado
        PolloAsado
        
        target encontrado craft hit
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " encontrado en posición " bind medio);
        PolloAsado
        miss
        PolloCrudo
            dropperSpider("Valor " bind valor_buscar bind " no encontrado");
        PolloAsado
    PolloAsado
    
    dropperSpider("Prueba de rendimiento completada.");

worldSave

$* 
   Prueba: 44_Prueba_Rend_TokensRepetidos
   Descripción: Verificar rendimiento con patrones repetitivos
   Fecha: 28/04/2025
*$

WorldName PruebaTokensRepetidos:

Bedrock
    Obsidian Stack MAX_ITERATIONS 500;
    Obsidian Stack PATTERN_LENGTH 20;

Inventory
    $$ Variables para la prueba
    Stack counter = 0;
    Stack total = 0;
    Stack temp = 0;
    Torch flag = On;

SpawnPoint
    dropperSpider("Iniciando prueba de rendimiento con tokens repetitivos");
    
    $$ =================================================================
    $$ Patrón 1: Repetición masiva de operaciones aritméticas
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones aritméticas que se repite
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        total = total + 1;
        total = total - 1;
        total = total + 2;
        total = total - 1;
        total = total + 3;
        total = total - 2;
        total = total * 2;
        total = total // 2;
        total = total + 5;
        total = total % 10;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 1 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 2: Repetición masiva de operaciones lógicas
    $$ =================================================================
    
    counter = 0;
    flag = On;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de operaciones lógicas que se repite
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag and On;
        flag = flag or Off;
        flag = not flag;
        flag = flag xor On;
        flag = flag xor Off;
        flag = flag and On;
        flag = not flag;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 2 completado. Estado final: " bind flag);
    
    $$ =================================================================
    $$ Patrón 3: Repetición masiva de evaluaciones condicionales
    $$ =================================================================
    
    counter = 0;
    total = 0;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de condicionales que se repite
        target counter % 2 is 0 craft hit
        PolloCrudo
            total += 1;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 3 is 0 craft hit
        PolloCrudo
            total += 3;
        PolloAsado
        miss
        PolloCrudo
            total += 1;
        PolloAsado
        
        target counter % 5 is 0 craft hit
        PolloCrudo
            total += 5;
        PolloAsado
        miss
        PolloCrudo
            total += 2;
        PolloAsado
        
        target counter % 7 is 0 craft hit
        PolloCrudo
            total += 7;
        PolloAsado
        miss
        PolloCrudo
            total += 3;
        PolloAsado
        
        target total > 1000 craft hit
        PolloCrudo
            total = total % 1000;
        PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 3 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 4: Repetición masiva de incremento/decremento
    $$ =================================================================
    
    counter = 0;
    total = 500;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de incremento/decremento que se repite
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand total;
        soulsand total;
        soulsand total;
        magma total;
        magma total;
        soulsand total;
        soulsand total;
        magma total;
        soulsand total;
        magma total;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 4 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 5: Repetición masiva de operaciones de asignación compuesta
    $$ =================================================================
    
    counter = 0;
    total = 5;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de asignaciones compuestas que se repite
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        total += 5;
        total -= 2;
        total *= 2;
        total //= 2;
        total %= 10;
        total += 1;
        total -= 1;
        total *= 3;
        total //= 3;
        total %= 5;
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 5 completado. Total: " bind total);
    
    $$ =================================================================
    $$ Patrón 6: Repetición masiva de operadores de comparación
    $$ =================================================================
    
    counter = 0;
    total = 0;
    temp = 50;
    
    repeater counter < MAX_ITERATIONS craft
    PolloCrudo
        $$ Patrón de comparaciones que se repite
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        target counter < temp craft hit total += 1; PolloAsado
        target counter > temp craft hit total += 1; PolloAsado
        target counter <= temp craft hit total += 1; PolloAsado
        target counter >= temp craft hit total += 1; PolloAsado
        target counter is temp craft hit total += 1; PolloAsado
        target counter isNot temp craft hit total += 1; PolloAsado
        target counter < 100 craft hit total += 1; PolloAsado
        target counter > 0 craft hit total += 1; PolloAsado
        target counter <= 100 craft hit total += 1; PolloAsado
        target counter >= 0 craft hit total += 1; PolloAsado
        
        soulsand counter;
    PolloAsado
    
    dropperSpider("Patrón 6 completado. Total: " bind total);
    
    dropperSpider("Prueba de rendimiento con tokens repetitivos completada.");

worldSave

$* 
   Prueba: 45_Prueba_Rend_TokensVariados
   Descripción: Verificar rendimiento con variedad de tokens mezclados
   Fecha: 28/04/2025
*$

WorldName PruebaTokensVariados:

$$ Sección de constantes para controlar el tamaño de la prueba
Bedrock
    Obsidian Stack ITERATIONS 100;
    Obsidian Stack MAX_VALUE 1000;
    Obsidian Stack ARRAY_SIZE 50;
    Obsidian Spider TEST_NAME "Prueba de rendimiento con tokens variados";
    Obsidian Spider VERSION "1.0";
    Obsidian Ghast PI 3.14159;
    Obsidian Torch DEBUG_MODE On;

$$ Definiciones de tipos variados para generar diversidad de tokens
ResourcePack
    Entity Posicion
    PolloCrudo
        Stack x;
        Stack y;
        Stack z;
    PolloAsado;

    Entity Item
    PolloCrudo
        Spider nombre;
        Stack cantidad;
        Stack durabilidad;
        Ghast peso;
        Torch consumible;
    PolloAsado;

    Entity Jugador
    PolloCrudo
        Spider nombre;
        Stack nivel;
        Ghast salud;
        Entity Posicion posicion;
        Shelf[10] Entity Item inventario;
    PolloAsado;

    Anvil Ghast -> Stack truncate;
    Anvil Stack -> Spider;
    Anvil Spider -> Stack;
    Anvil Stack -> Torch;

Inventory
    Stack contador = 0;
    Stack suma = 0;
    Stack producto = 1;

    Ghast pi = 3.14159;
    Ghast e = 2.71828;
    Ghast resultado_flotante = 0.0;

    Spider texto = "Prueba de rendimiento";
    Spider resultado_texto = "";

    Rune caracter = 'A';
    Torch condicion = On;

    Shelf[ARRAY_SIZE] Stack numeros;
    Shelf[ARRAY_SIZE] Ghast valores_reales;
    Shelf[10] Spider textos = ["uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"];

    Chest conjunto_numeros = {: 1, 2, 3, 4, 5 :};
    Chest conjunto_caracteres = {: 'a', 'b', 'c', 'd', 'e' :};

    Book archivo_log = {/ "log.txt", 'E' /};
    Book archivo_datos = {/ "datos.dat", 'L' /};

    Entity Posicion origen
    PolloCrudo
        x: 0;
        y: 0;
        z: 0;
    PolloAsado;

    Entity Item espada
    PolloCrudo
        nombre: "Espada de diamante";
        cantidad: 1;
        durabilidad: 1000;
        peso: 5.0;
        consumible: Off;
    PolloAsado;

    Entity Jugador jugador_principal;
    Entity Jugador jugadores[5];

Recipe
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack;
    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast;
    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item;

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud);
    Ritual mostrarEstadisticas(Entity Jugador :: jugador);
    Ritual procesarInventario(Shelf[10] Entity Item :: inventario);

CraftingTable
    Spell calcularDanio(Stack :: nivel; Ghast :: multiplicador) -> Stack
    PolloCrudo
        Stack danio_base = nivel * 2 + 5;
        Stack danio_final = danio_base;

        target nivel > 10 craft hit
        PolloCrudo
            danio_final += (nivel - 10) * 3;
        PolloAsado

        Ghast temp = danio_final >> Ghast;
        temp = temp :* multiplicador;
        danio_final = temp >> Stack;

        respawn danio_final;
    PolloAsado

    Spell distanciaEntre(Entity Posicion :: pos1, pos2) -> Ghast
    PolloCrudo
        Stack dx = pos1@x - pos2@x;
        Stack dy = pos1@y - pos2@y;
        Stack dz = pos1@z - pos2@z;

        Ghast dx_float = dx >> Ghast;
        Ghast dy_float = dy >> Ghast;
        Ghast dz_float = dz >> Ghast;

        Ghast suma_cuadrados = (dx_float :* dx_float) :+ (dy_float :* dy_float) :+ (dz_float :* dz_float);
        Ghast result = suma_cuadrados :// 2.0;
        respawn result;
    PolloAsado

    Spell crearItem(Spider :: nombre; Stack cantidad, durabilidad; Ghast peso; Torch consumible) -> Entity Item
    PolloCrudo
        Entity Item nuevo_item
        PolloCrudo
            nombre: nombre;
            cantidad: cantidad;
            durabilidad: durabilidad;
            peso: peso;
            consumible: consumible;
        PolloAsado;
        respawn nuevo_item;
    PolloAsado

    Ritual inicializarJugador(Entity Jugador ref jugador; Spider :: nombre; Stack nivel; Ghast salud)
    PolloCrudo
        jugador@nombre = nombre;
        jugador@nivel = nivel;
        jugador@salud = salud;
        jugador@posicion@x = 0;
        jugador@posicion@y = 0;
        jugador@posicion@z = 0;

        walk i set 0 to 9 craft
        PolloCrudo
            jugador@inventario[i] = crearItem("Item_" bind i, i + 1, 100 * (i + 1), i :* 0.5, i % 2 is 0);
        PolloAsado
    PolloAsado

    Ritual mostrarEstadisticas(Entity Jugador :: jugador)
    PolloCrudo
        dropperSpider("=== Estadísticas del Jugador ===");
        dropperSpider("Nombre: " bind jugador@nombre);
        dropperSpider("Nivel: " bind jugador@nivel);
        dropperSpider("Salud: " bind jugador@salud);
        dropperSpider("Posición: (" bind jugador@posicion@x bind ", " bind jugador@posicion@y bind ", " bind jugador@posicion@z bind ")");
        dropperSpider("Inventario: " bind #(jugador@inventario) bind " items");
    PolloAsado

    Ritual procesarInventario(Shelf[10] Entity Item :: inventario)
    PolloCrudo
        Stack total_items = 0;
        Ghast peso_total = 0.0;
        Spider lista_items = "";

        walk i set 0 to 9 craft
        PolloCrudo
            total_items += inventario[i]@cantidad;
            peso_total = peso_total :+ (inventario[i]@peso :* inventario[i]@cantidad >> Ghast);

            target i < 9 craft hit
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre bind ", ";
            PolloAsado
            miss
            PolloCrudo
                lista_items = lista_items bind inventario[i]@nombre;
            PolloAsado
        PolloAsado

        dropperSpider("Total items: " bind total_items);
        dropperSpider("Peso total: " bind peso_total);
        dropperSpider("Lista: " bind lista_items);
    PolloAsado

SpawnPoint
    dropperSpider(TEST_NAME bind " v" bind VERSION);

    walk i set 0 to ARRAY_SIZE - 1 craft
    PolloCrudo
        numeros[i] = (i * i + i) % MAX_VALUE;
        valores_reales[i] = i :* PI :// 10.0;

        target i < 20 craft hit
        PolloCrudo
            add(conjunto_numeros, i * 10);
        PolloAsado
    PolloAsado

    jugador_principal@nombre = "Aventurero";
    jugador_principal@nivel = 25;
    jugador_principal@salud = 95.5;
    jugador_principal@posicion@x = 100;
    jugador_principal@posicion@y = 64;
    jugador_principal@posicion@z = -50;

    walk i set 0 to 4 craft
    PolloCrudo
        Spider nombre_jugador = "Jugador_" bind i;
        Stack nivel_inicial = 1 + i * 5;
        Ghast salud_inicial = 20.0 :+ (i :* 5.0);
        ender_pearl inicializarJugador(jugadores[i], nombre_jugador, nivel_inicial, salud_inicial);
    PolloAsado

    dropperSpider("Realizando operaciones mezcladas...");

    contador = 0;
    suma = 0;
    producto = 1;
    resultado_texto = "";

    walk iteracion set 0 to ITERATIONS - 1 craft
    PolloCrudo
        Stack indice = iteracion % ARRAY_SIZE;
        suma += numeros[indice];
        target producto < 1000000 craft hit
        PolloCrudo
            producto *= (indice + 1);
        PolloAsado

        Ghast valor_real = valores_reales[indice];
        resultado_flotante = resultado_flotante :+ valor_real;
        target resultado_flotante :> 1000.0 craft hit
        PolloCrudo
            resultado_flotante = resultado_flotante :% 1000.0;
        PolloAsado

        Spider texto_iteracion = textos[iteracion % 10];
        target iteracion % 5 is 0 craft hit
        PolloCrudo
            resultado_texto = resultado_texto bind texto_iteracion;
        PolloAsado

        target iteracion % 2 is 0 craft hit
        PolloCrudo
            caracter = etchUp(caracter);
        PolloAsado
        miss
        PolloCrudo
            caracter = etchDown(caracter);
        PolloAsado

        condicion = condicion xor (iteracion % 3 is 0);
        target indice % 2 is 0 and condicion craft hit
        PolloCrudo
            soulsand contador;
        PolloAsado

        target iteracion % 10 is 0 craft hit
        PolloCrudo
            Stack danio = calcularDanio(jugador_principal@nivel, 1.5);
            Ghast distancia = distanciaEntre(jugador_principal@posicion, origen);

            dropperSpider("Iteración " bind iteracion bind ": Daño=" bind danio bind ", Distancia=" bind distancia);
        PolloAsado

        Stack jugador_indice = iteracion % 5;
        soulsand jugadores[jugador_indice]@nivel;

        target iteracion % 20 is 0 craft hit
        PolloCrudo
            ender_pearl mostrarEstadisticas(jugadores[jugador_indice]);
        PolloAsado
    PolloAsado

    dropperSpider("Prueba completada. Resultados:");
    dropperSpider("Suma total: " bind suma);
    dropperSpider("Producto acumulado: " bind producto);
    dropperSpider("Resultado flotante: " bind resultado_flotante);
    dropperSpider("Texto resultante: " bind resultado_texto);
    dropperSpider("Caracter final: " bind caracter);
    dropperSpider("Contador incrementado: " bind contador);
    dropperSpider("Estado de condición final: " bind condicion);

    ender_pearl procesarInventario(jugador_principal@inventario);

    dropperSpider("Prueba de rendimiento con tokens variados finalizada");

worldSave


